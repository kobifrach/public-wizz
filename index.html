<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='52' font-size='52'%3E%E2%9C%88%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Search</title>
    <style>
        html {
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }

        form {
            width: 100%;
            max-width: 420px;
            margin: 12px auto;
            padding: 10px 6px 16px 6px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        label {
            display: block;
            margin-bottom: 2px;
            font-weight: bold;
            font-size: 15px;
        }

        input[type="email"],
        input[type="text"],
        select,
        input[list] {
            width: 100%;
            padding: 10px 8px;
            margin-bottom: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            background: #fafbfc;
        }

        input[list] {
            min-width: 0;
        }

        fieldset {
            border: none;
            margin-bottom: 10px;
            padding: 0;
        }

        legend {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        button {
            display: inline-block;
            padding: 10px 0;
            font-size: 16px;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 8px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button[type="button"] {
            margin-top: 4px;
            width: auto;
            padding: 7px 16px;
            font-size: 15px;
        }

        /* Small subtle button used inside multi-select widgets */
        .multiselect-select-all {
            display: inline-block;
            padding: 4px 8px;
            margin: 6px 0 8px 0;
            font-size: 13px;
            background: transparent;
            color: #007bff;
            border: 1px solid rgba(0,123,255,0.15);
            border-radius: 4px;
            cursor: pointer;
            width: auto;
        }

        .multiselect-select-all:hover {
            background: rgba(0,123,255,0.06);
        }

        /* Small checkbox used inside multi-select widgets */
        .multiselect-select-all-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        div {
            margin-bottom: 10px;
        }

        .multi-select-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .row {
            background-color: #f9f9f9;
            padding: 7px 6px 7px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 7px;
            position: relative;
            min-height: 36px;
        }

        .remove-row-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            padding: 8px 10px !important;
            font-size: 18px;
            font-weight: 900;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            line-height: 1;
            z-index: 2;
            height: 34px;
        }

        .remove-row-btn:hover {
            background: #c0392b;
        }

        #add-row-container {
            text-align: center;
            margin-bottom: 10px;
        }

        .divider {
            height: 1px;
            background-color: #ddd;
            margin: 12px 0;
        }

        #dates-checkboxes label {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 2px;
            font-weight: normal;
            font-size: 14px;
        }

        /* #select-all-dates {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 14px;
            padding: 6px 12px;
        }
 */
        [type="submit"] {
            width: 100%;
            margin: 0;
            font-size: 18px;
            padding: 12px 0;
        }

        h1 {
            font-size: 1.5em;
            margin: 18px 0 10px 0;
            letter-spacing: 1px;
        }

        @media (min-width: 600px) {
            form {
                max-width: 480px;
                padding: 18px 24px 24px 24px;
            }

            h1 {
                font-size: 2.1em;
                margin: 32px 0 12px 0;
            }

            input[type="email"],
            input[type="text"],
            select,
            input[list] {
                font-size: 15px;
                padding: 8px 10px;
            }

            button {
                font-size: 15px;
                padding: 10px 0;
            }

            [type="submit"] {
                font-size: 17px;
                padding: 13px 0;
            }
        }
        /* Compact per-row dates: keep checkboxes and select-all on one line when possible */
        .row-dates-checkboxes {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap; /* allow wrapping on very small screens */
        }
        .row-dates-checkboxes label {
            margin-bottom: 0;
            white-space: nowrap; /* keep each date together */
            font-weight: normal;
            font-size: 13px;
        }
        .row > .multiselect-select-all {
            margin-left: 8px;
            margin-top: 0;
            margin-bottom: 0;
            vertical-align: middle;
        }
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.92);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        #loading-overlay .box {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 18px 20px;
            max-width: 520px;
            box-shadow: 0 4px 18px rgba(0,0,0,0.08);
            text-align: center;
        }
        .spinner {
            width: 28px;
            height: 28px;
            border: 3px solid #e5e7eb;
            border-top-color: #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Results modal */
        #results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
            padding: 14px;
        }
        #results-modal .modal {
            background: #fff;
            border-radius: 10px;
            width: min(980px, 96vw);
            max-height: 88vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        #results-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            border-bottom: 1px solid #eee;
            position: relative; /* allow absolutely positioned centered button */
        }
        #results-modal .modal-body {
            padding: 12px 14px;
            overflow: auto;
        }
        #results-close-btn {
            border: none;
            background: #e5e7eb;
            color: #111827;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 13px;
            height: auto;
            width: 44px;
        }
        #results-close-btn:hover { background: #d1d5db; }
        /* Center the download button in the modal header without moving the close X (which stays on the right).
           We use absolute positioning and transform to center horizontally. Keep a sensible z-index. */
        #results-download-btn {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            padding: 6px 12px;
            font-size: 13px;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        #results-download-btn:hover { background: #0056b3; }
        .results-section { margin-bottom: 16px; }
        .pill {
            display: inline-block;
            background: #f3f4f6;
            color: #374151;
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 12px;
            margin-left: 8px;
        }
        .card {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 10px 12px;
            margin: 8px 0;
            background: #fafbfc;
        }
        .table-wrap { overflow: auto; border: 1px solid #eee; border-radius: 6px; }
        table.results { border-collapse: collapse; width: 100%; font-size: 14px; }
        table.results th, table.results td { border: 1px solid #eee; padding: 6px 8px; text-align: left; }
        table.results th { background: #f9fafb; position: sticky; top: 0; z-index: 1; }
    </style>
</head>

<body>
    <h1 style="text-align:center; font-size:2em; margin:32px 0 12px 0; letter-spacing:1px;">
        ‚úàÔ∏è Wizz Flights Search
    </h1>
    <form id="flight-search-form" style="overflow-x: auto;">
        <!-- User Credentials -->
        <label for="username">Username (Email):</label>
        <input type="email" id="username" name="username" autocomplete="username" required>

        <label for="password">Password:</label>
        <input type="text" id="password" name="password" autocomplete="password" required>

        <!-- Connection Mode -->
        <fieldset>
            <legend>Connection Mode:</legend>
            <label>
                <input type="radio" name="connection" value="none" checked> None
            </label>
            <label>
                <input type="radio" name="connection" value="with"> With
            </label>
        </fieldset>

        <!-- Dynamic Content -->
        <div id="dynamic-content"></div>

        <div class="divider"></div>

        <!-- Date Selector -->
    <label for="dates" id="global-dates-label">Select Dates:</label>
    <div id="dates-checkboxes"></div>
    <!-- <button type="button" id="select-all-dates">Select All</button> -->

        <!-- Start Button -->
        <div style="text-align: center; margin: 24px 0;">
            <button type="submit">Start</button>
        </div>
    </form>

    <!-- Loading overlay -->
    <div id="loading-overlay" role="status" aria-live="polite">
        <div class="box">
            <div>
                <span class="spinner" aria-hidden="true"></span>
                <strong>Loading‚Ä¶</strong>
            </div>
            <div style="margin-top:8px; font-size:14px; color:#374151;">
                Request sent. Please do not close the window until completion. If you want to send another request, you can open a new tab.
            </div>
        </div>
    </div>

    <!-- Results modal -->
    <div id="results-modal" aria-modal="true" role="dialog">
        <div class="modal">
            <div class="modal-header">
                <h2 id="results-title" style="margin:0; font-size:18px;">Search Results</h2>
                <button id="results-close-btn" title="Close">X</button>
            </div>
            <div class="modal-body" id="results-body"></div>
        </div>
    </div>

    <script>
        // pairs: originCode -> [destinationCode]
        // codeToName: airportCode -> display name
        // allDestinationsOptions: [{code, name}] deduplicated
    let pairs = {};
    let codeToName = {};
    let codeToCountry = {};
    let allDestinationsOptions = [];

        // Helper: from a display string like "Bucharest (OTP)" return the code "OTP"
        function extractCode(value) {
            if (!value) return '';
            const match = String(value).match(/\(([^)]+)\)\s*$/);
            if (match) return match[1].trim();
            const upper = String(value).trim().toUpperCase();
            if (codeToName[upper]) return upper; // already a code
            return String(value).trim();
        }

        Promise.all([
            fetch('updated_pairs.json').then(r => r.json()).catch(() => []),
            fetch('airports_origins.json').then(r => r.json()).catch(() => [])
        ])
            .then(([data, airports]) => {
                // Build country mapping
                codeToCountry = {};
                (Array.isArray(airports) ? airports : []).forEach(a => {
                    if (a && a.code) codeToCountry[a.code] = a.country || 'Not Updated Country';
                });

                // data is an array of { code, name, destinations: [{code, name}] }
                const destMap = new Map();
                pairs = {};
                codeToName = {};
                (Array.isArray(data) ? data : []).forEach(origin => {
                    const oCode = origin.code;
                    const oName = origin.name;
                    if (oCode) {
                        codeToName[oCode] = oName || oCode;
                        if (origin.country && !codeToCountry[oCode]) codeToCountry[oCode] = origin.country;
                    }
                    const dests = Array.isArray(origin.destinations) ? origin.destinations : [];
                    pairs[oCode] = dests.map(d => {
                        if (d && d.code) {
                            codeToName[d.code] = d.name || d.code;
                            if (d.country && !codeToCountry[d.code]) codeToCountry[d.code] = d.country;
                            if (!destMap.has(d.code)) destMap.set(d.code, { code: d.code, name: d.name || d.code });
                            return d.code;
                        }
                        return null;
                    }).filter(Boolean);
                });
                allDestinationsOptions = Array.from(destMap.values());
                // Ensure every known origin and destination code has a country entry
                Object.keys(pairs).forEach(oCode => {
                    if (!codeToCountry[oCode]) codeToCountry[oCode] = 'NOT UPDATED COUNTRY';
                    const dests = Array.isArray(pairs[oCode]) ? pairs[oCode] : [];
                    dests.forEach(dCode => {
                        if (!codeToCountry[dCode]) codeToCountry[dCode] = 'NOT UPDATED COUNTRY';
                    });
                });
                // Also ensure any standalone destinations from the master list have a country
                allDestinationsOptions.forEach(({ code }) => {
                    if (!codeToCountry[code]) codeToCountry[code] = 'NOT UPDATED COUNTRY';
                });
                initialize();
            })
            .catch(error => console.error('Error loading data:', error));

        function initialize() {
            const allDestinations = allDestinationsOptions;

            const today = new Date();
            const formatDate = (date) => {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            };

            const dateOptions = [
                { value: 'today', label: formatDate(today) },
                { value: 'tomorrow', label: formatDate(new Date(today.getTime() + 86400000)) },
                { value: 'day-after-tomorrow', label: formatDate(new Date(today.getTime() + 2 * 86400000)) },
                { value: 'two-days-after-tomorrow', label: formatDate(new Date(today.getTime() + 3 * 86400000)) }
            ];

            const dynamicContent = document.getElementById('dynamic-content');
            const connectionRadios = document.getElementsByName('connection');
            const selectAllDatesButton = document.getElementById('select-all-dates');
            const datesCheckboxes = document.getElementById('dates-checkboxes');
            const globalDatesLabel = document.getElementById('global-dates-label');

            function renderDateCheckboxes() {
                datesCheckboxes.innerHTML = '';
                const today = new Date();
                for (let i = 0; i < 4; i++) {
                    const date = new Date(today.getTime() + i * 86400000);
                    const day = String(date.getDate()).padStart(2, '0');
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const year = date.getFullYear();
                    const dateStr = `${day}/${month}/${year}`;
                    const label = document.createElement('label');
                    label.style.fontWeight = 'normal';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = 'dates';
                    checkbox.value = dateStr;
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' ' + dateStr));
                    datesCheckboxes.appendChild(label);
                    datesCheckboxes.appendChild(document.createElement('br'));
                }
            }

            renderDateCheckboxes();

            connectionRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    dynamicContent.innerHTML = '';

                    const showGlobalDates = (show) => {
                        if (globalDatesLabel) globalDatesLabel.style.display = show ? 'block' : 'none';
                        if (datesCheckboxes) datesCheckboxes.style.display = show ? 'block' : 'none';
                        if (selectAllDatesButton) selectAllDatesButton.style.display = show ? 'inline-block' : 'none';
                    };

                    // --- WITH mode ---
                    if (radio.value === 'with') {
                        showGlobalDates(true);

                        const fromLabel = document.createElement('label');
                        fromLabel.textContent = 'FROM';
                        fromLabel.style.display = 'block';
                        fromLabel.style.fontWeight = 'bold';
                        const originOptions = Object.keys(pairs).map(code => ({ code, name: codeToName[code] || code }));
                        const originSelect = createComboBox(originOptions, 'origin');
                        fromLabel.appendChild(originSelect);

                        // Trigger change to populate destinations if any
                        const originSelectEl = originSelect.querySelector('select[name="origin"]');
                        if (originSelectEl) originSelectEl.dispatchEvent(new Event('change'));

                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        const destinationSelect = createComboBox(allDestinations, 'destination');
                        toLabel.appendChild(destinationSelect);

                        dynamicContent.appendChild(fromLabel);
                        dynamicContent.appendChild(toLabel);

                        // Change global dates to radios
                        datesCheckboxes.querySelectorAll('input').forEach(input => {
                            input.type = 'radio';
                            input.name = 'global-date';
                        });
                    } else {
                        // NONE mode: hide global dates and render rows with per-row date selectors
                        showGlobalDates(false);
                        renderRowsContainer();

                        // Change global dates to checkboxes
                        datesCheckboxes.querySelectorAll('input').forEach(input => {
                            input.type = 'checkbox';
                            input.removeAttribute('name');
                        });
                    }
                });
            });

            // Repopulate a multi-select with options grouped by country (uses <optgroup>)
            function repopulateMultiSelect(select, list, searchInput) {
                const items = (list || []).map(opt => {
                    const code = typeof opt === 'string' ? opt : opt.code;
                    const name = typeof opt === 'string' ? (codeToName[code] || code) : (opt.name || opt.code);
                    const country = codeToCountry[code] || 'Other';
                    return { code, name, country };
                });
                const grouped = new Map();
                items.forEach(it => {
                    const key = it.country || 'Other';
                    if (!grouped.has(key)) grouped.set(key, []);
                    grouped.get(key).push(it);
                });
                const countries = Array.from(grouped.keys()).sort((a, b) => {
                    const NU = 'NOT UPDATED COUNTRY';
                    const ax = a === NU ? 1 : 0;
                    const bx = b === NU ? 1 : 0;
                    if (ax !== bx) return ax - bx; // NU last
                    return a.localeCompare(b);
                });
                select.innerHTML = '';
                countries.forEach(cty => {
                    const og = document.createElement('optgroup');
                    og.label = cty;
                    grouped.get(cty).sort((a, b) => a.name.localeCompare(b.name)).forEach(({ code, name }) => {
                        const opt = document.createElement('option');
                        opt.value = code;
                        opt.textContent = `${name} (${code})`;
                        opt.dataset.searchKey = `${name} ${code} ${cty}`.toLowerCase();
                        og.appendChild(opt);
                    });
                    select.appendChild(og);
                });
                if (searchInput && searchInput.value && searchInput.value.trim()) {
                    const q = searchInput.value.trim().toLowerCase();
                    for (const opt of select.options) {
                        const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                        opt.hidden = q && !key.includes(q);
                    }
                    // Hide optgroups that have no visible children
                    Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                        const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                        og.hidden = !anyVisible;
                    });
                }
            }

            // Show a small country hint near an origin input/select inside container
            function attachCountryHint(container, fieldName) {
                const el = container.querySelector(`[name="${fieldName}"]`);
                if (!el) return;
                const hint = document.createElement('small');
                hint.style.marginLeft = '6px';
                hint.style.color = '#666';
                hint.style.fontSize = '12px';
                const update = () => {
                    const code = extractCode(el.value || '');
                    const country = codeToCountry[code];
                    hint.textContent = country ? `(${country})` : '';
                };
                el.addEventListener('input', update);
                el.addEventListener('change', update);
                setTimeout(update, 0);
                container.appendChild(hint);
            }

            function createComboBox(options, name, onChangeCallback, isMultiSelect = false) {
                const normalize = (opt) => {
                    if (typeof opt === 'string') {
                        const code = opt;
                        const nm = codeToName[code] || code;
                        return { code, name: nm };
                    }
                    return { code: opt.code, name: opt.name || opt.code };
                };
                const normalized = (options || []).map(normalize);
                if (isMultiSelect) {
                    // MULTI-SELECT with live search filtering
                    const container = document.createElement('div');
                    // Search input
                    const search = document.createElement('input');
                    search.type = 'text';
                    search.placeholder = 'üîé Search destinations‚Ä¶';
                    search.setAttribute('data-search-for', name);
                    search.style.marginBottom = '6px';
                    search.style.width = '100%';
                    search.style.padding = '8px 10px';
                    search.style.border = '1px solid #ccc';
                    search.style.borderRadius = '4px';

                    // Select element
                    const select = document.createElement('select');
                    select.name = name;
                    select.multiple = true;

                    const populateOptions = (list) => {
                        repopulateMultiSelect(select, list, search);
                        // Update the select-all checkbox state after repopulating
                        try { updateSelectAllState(); } catch (e) { /* ignore if not yet defined */ }
                    };

                    const applyFilter = (query) => {
                        const q = query.toLowerCase();
                        for (const opt of select.options) {
                            const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                            opt.hidden = q && !key.includes(q);
                        }
                        // Hide optgroups with no visible children
                        Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                            const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                            og.hidden = !anyVisible;
                        });
                        // Reflect the current visible selection in the checkbox
                        try { updateSelectAllState(); } catch (e) { /* ignore if not yet defined */ }
                    };

                    populateOptions(normalized);

                    if (onChangeCallback) select.addEventListener('change', onChangeCallback);
                    // Keep the select-all checkbox in sync when user selects/deselects options
                    select.addEventListener('change', () => {
                        try { updateSelectAllState(); } catch (e) { /* ignore */ }
                    });
                    search.addEventListener('input', () => applyFilter(search.value.trim()));
                    // Prevent Enter from submitting the form while searching
                    search.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') e.preventDefault();
                    });

                    // Create checkbox + label to toggle select-all for visible options
                    const selectAllWrapper = document.createElement('div');
                    selectAllWrapper.style.display = 'flex';
                    selectAllWrapper.style.alignItems = 'center';
                    selectAllWrapper.style.gap = '8px';
                    selectAllWrapper.style.margin = '6px 0';

                    const selectAllCheckbox = document.createElement('input');
                    selectAllCheckbox.type = 'checkbox';
                    selectAllCheckbox.id = `select-all-${name}`;
                    selectAllCheckbox.className = 'multiselect-select-all-checkbox';

                    const selectAllLabel = document.createElement('label');
                    selectAllLabel.setAttribute('for', selectAllCheckbox.id);
                    selectAllLabel.textContent = 'select all destinations';
                    selectAllLabel.style.fontSize = '13px';
                    selectAllLabel.style.color = '#007bff';

                    // Toggle selects only visible (not hidden) options. If checked -> select visible; if unchecked -> deselect visible.
                    selectAllCheckbox.addEventListener('change', () => {
                        const shouldSelect = selectAllCheckbox.checked;
                        for (const option of select.options) {
                            if (!option.hidden) option.selected = shouldSelect;
                        }
                        // Fire change event so any listeners react to selection changes
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    // Helper: update checkbox state (checked/indeterminate) based on visible options
                    function updateSelectAllState() {
                        const visible = Array.from(select.options).filter(o => !o.hidden);
                        if (visible.length === 0) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                            return;
                        }
                        const selectedCount = visible.filter(o => o.selected).length;
                        if (selectedCount === 0) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                        } else if (selectedCount === visible.length) {
                            selectAllCheckbox.checked = true;
                            selectAllCheckbox.indeterminate = false;
                        } else {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = true;
                        }
                    }

                    selectAllWrapper.appendChild(selectAllCheckbox);
                    selectAllWrapper.appendChild(selectAllLabel);

                    // Order: search (top), then checkbox+label, then the multi-select list
                    container.appendChild(search);
                    container.appendChild(selectAllWrapper);
                    container.appendChild(select);

                    // Best-effort: clicking an optgroup label selects all its visible options
                    select.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target && target.tagName === 'OPTGROUP') {
                            const opts = Array.from(target.querySelectorAll('option'));
                            const visible = opts.filter(o => !o.hidden);
                            const shouldSelect = visible.some(o => !o.selected);
                            visible.forEach(o => { o.selected = shouldSelect; });
                            select.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                    return container;
                } else {
                    // SINGLE select
                    if (['origin', 'destination'].includes(name)) {
                        // Render as a searchable SELECT grouped by country
                        const container = document.createElement('div');
                        const search = document.createElement('input');
                        search.type = 'text';
                        search.placeholder = name === 'destination' ? 'üîé Search destinations‚Ä¶' : 'üîé Search origins‚Ä¶';
                        search.style.marginBottom = '6px';
                        search.style.width = '100%';
                        search.style.padding = '8px 10px';
                        search.style.border = '1px solid #ccc';
                        search.style.borderRadius = '4px';

                        const select = document.createElement('select');
                        select.name = name;

                        const buildOptions = () => {
                            // Build grouped options by country
                            const byCountry = new Map();
                            normalized.forEach(({ code, name }) => {
                                const country = codeToCountry[code] || 'Other';
                                if (!byCountry.has(country)) byCountry.set(country, []);
                                byCountry.get(country).push({ code, name });
                            });
                            const NU = 'NOT UPDATED COUNTRY';
                            const countries = Array.from(byCountry.keys()).sort((a, b) => {
                                const ax = a === NU ? 1 : 0;
                                const bx = b === NU ? 1 : 0;
                                if (ax !== bx) return ax - bx;
                                return a.localeCompare(b);
                            });
                            select.innerHTML = '';
                            countries.forEach(country => {
                                const og = document.createElement('optgroup');
                                og.label = country;
                                byCountry.get(country).sort((a, b) => a.name.localeCompare(b.name)).forEach(({ code, name }) => {
                                    const opt = document.createElement('option');
                                    opt.value = code;
                                    opt.textContent = `${name} (${code})`;
                                    opt.dataset.searchKey = `${name} ${code} ${country}`.toLowerCase();
                                    og.appendChild(opt);
                                });
                                select.appendChild(og);
                            });
                        };
                        buildOptions();

                        // Set default to TLV for origin
                        if (name === 'origin') select.value = 'TLV';

                        const applyFilter = (query) => {
                            const q = query.toLowerCase();
                            for (const opt of select.options) {
                                const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                                opt.hidden = q && !key.includes(q);
                            }
                            // Hide optgroups with no visible children
                            Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                                const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                                og.hidden = !anyVisible;
                            });
                        };

                        search.addEventListener('input', () => applyFilter(search.value.trim()));
                        // Prevent Enter from submitting the form while searching
                        search.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') e.preventDefault();
                        });

                        if (onChangeCallback) select.addEventListener('change', onChangeCallback);

                        container.appendChild(search);
                        container.appendChild(select);
                        return container;
                    } else {
                        // Keep input+datalist UX for other single selects
                        const input = document.createElement('input');
                        input.setAttribute('list', `datalist-${name}`);
                        input.name = name;
                        input.autocomplete = 'off';
                        const datalist = document.createElement('datalist');
                        datalist.id = `datalist-${name}`;
                        normalized.forEach(({ code, name }) => {
                            const opt = document.createElement('option');
                            opt.value = `${name} (${code})`;
                            datalist.appendChild(opt);
                        });
                        if (onChangeCallback) input.addEventListener('change', onChangeCallback);
                        const container = document.createElement('span');
                        container.appendChild(input);
                        container.appendChild(datalist);
                        return container;
                    }
                }
            }

            // Helper to create per-row date selector (4 upcoming days) with "Select All" button
            function createRowDateSelector(preselectedDates = []) {
                const container = document.createElement('div');
                const label = document.createElement('label');
                label.textContent = 'Select Dates:';
                label.style.display = 'block';
                label.style.fontWeight = 'bold';

                const cbWrap = document.createElement('div');
                cbWrap.className = 'row-dates-checkboxes';

                const today = new Date();
                const toDMY = (date) => {
                    const d = String(date.getDate()).padStart(2, '0');
                    const m = String(date.getMonth() + 1).padStart(2, '0');
                    const y = date.getFullYear();
                    return `${d}/${m}/${y}`;
                };

                // build 4 day checkboxes
                const selectedDMY = new Set(preselectedDates);
                for (let i = 0; i < 4; i++) {
                        const date = new Date(today.getTime() + i * 86400000);
                        const dmy = toDMY(date); // DD/MM/YYYY used as value for API
                        const lbl = document.createElement('label');
                        lbl.style.fontWeight = 'normal';
                        lbl.style.display = 'inline-block';
                        lbl.style.marginRight = '6px';
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.name = 'row-date';
                        cb.value = dmy; // keep year in value for API
                        if (selectedDMY.has(dmy)) cb.checked = true;
                        lbl.appendChild(cb);
                        // Display without year to save horizontal space (DD/MM)
                        lbl.appendChild(document.createTextNode(' ' + dmy.slice(0,5)));
                        cbWrap.appendChild(lbl);
                }

                // create a select-all checkbox (can select/deselect and show indeterminate)
                const selectAllWrapper = document.createElement('div');
                selectAllWrapper.style.display = 'inline-flex';
                selectAllWrapper.style.alignItems = 'center';
                selectAllWrapper.style.gap = '6px';
                selectAllWrapper.style.marginLeft = '8px';

                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.className = 'row-select-all-checkbox';
                selectAllCheckbox.title = 'Select/Deselect all visible dates';

                const selectAllLabel = document.createElement('label');
                selectAllLabel.style.fontSize = '13px';
                selectAllLabel.style.color = '#007bff';
                selectAllLabel.textContent = 'select all';

                // Toggle visible checkboxes when user clicks the select-all checkbox
                selectAllCheckbox.addEventListener('change', () => {
                    const shouldCheck = selectAllCheckbox.checked;
                    cbWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = shouldCheck);
                });

                // Keep select-all checkbox state in sync with children
                function updateSelectAllState() {
                    const all = Array.from(cbWrap.querySelectorAll('input[type="checkbox"]'));
                    const visible = all.filter(cb => !cb.hidden);
                    if (visible.length === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                        return;
                    }
                    const checkedCount = visible.filter(cb => cb.checked).length;
                    if (checkedCount === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else if (checkedCount === visible.length) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true;
                    }
                }

                // Attach listeners to children to update state
                cbWrap.addEventListener('change', (e) => {
                    if (e.target && e.target.type === 'checkbox') updateSelectAllState();
                });

                // Initialize state
                setTimeout(updateSelectAllState, 0);

                selectAllWrapper.appendChild(selectAllCheckbox);
                selectAllWrapper.appendChild(selectAllLabel);

                container.appendChild(label);
                container.appendChild(cbWrap);
                container.appendChild(selectAllWrapper);

                return {
                    root: container,
                    getSelectedDMY: () => Array.from(cbWrap.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value),
                    setSelectedDMY: (arr) => {
                        const set = new Set(arr || []);
                        cbWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = set.has(cb.value));
                    }
                };
            }

            function createNoneRow(copyDatesFrom = []) {
                const row = document.createElement('div');
                row.classList.add('row');

                const fromAnywhereCheckbox = document.createElement('input');
                fromAnywhereCheckbox.type = 'checkbox';
                fromAnywhereCheckbox.name = 'from-anywhere';

                const fromAnywhereLabel = document.createElement('label');
                fromAnywhereLabel.textContent = 'From Anywhere';
                fromAnywhereLabel.appendChild(fromAnywhereCheckbox);

                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.textContent = '‚Äî';
                removeButton.className = 'remove-row-btn';
                removeButton.title = 'Remove Row';
                removeButton.addEventListener('click', () => {
                    row.remove();
                });

                const originSelect = createComboBox(Object.keys(pairs), 'origin', () => {
                    // Handle both input+datalist and multiselect
                    let selectedOrigin = null;
                    // If originSelect is input+datalist
                    if (originSelect.querySelector('input[name="origin"]')) {
                        selectedOrigin = extractCode(originSelect.querySelector('input[name="origin"]').value);
                    } else if (originSelect.querySelector && originSelect.querySelector('select[name="origin"]')) {
                        selectedOrigin = originSelect.querySelector('select[name="origin"]').value;
                    } else if (originSelect.value !== undefined) {
                        selectedOrigin = originSelect.value; // fallback (in case originSelect IS the select)
                    }
                    const destinationOptions = (pairs[selectedOrigin] || []).map(code => ({ code, name: codeToName[code] || code }));
                    // Find the destination select (could be inside a label)
                    let destinationSelect = row.querySelector('select[name="destination"]');
                    if (!destinationSelect) {
                        // If not found directly, search inside labels
                        const toLabel = Array.from(row.querySelectorAll('label')).find(l => l.textContent.startsWith('TO'));
                        if (toLabel) destinationSelect = toLabel.querySelector('select[name="destination"]');
                    }
                    if (destinationSelect) {
                        const searchInput = row.querySelector('input[data-search-for="destination"]');
                        repopulateMultiSelect(destinationSelect, destinationOptions, searchInput);
                        // Dispatch change so the select-all checkbox for this destinationSelect updates
                        destinationSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });

                const destinationSelect = createComboBox([], 'destination', null, true);

                // Per-row date selector
                const rowDateSelector = createRowDateSelector(copyDatesFrom);

                // When row is rendered, also trigger the originSelect change to fill destination
                function renderRowContent() {
                    row.innerHTML = '';
                    row.appendChild(removeButton);
                    row.appendChild(fromAnywhereLabel);
                    if (fromAnywhereCheckbox.checked) {
                        // Only TO
                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        const anywhereSelect = createComboBox(allDestinations, 'anywhere', null, false);
                        toLabel.appendChild(anywhereSelect);
                        row.appendChild(toLabel);
                        // Dates for this row
                        row.appendChild(rowDateSelector.root);
                    } else {
                        // Always show FROM and TO when not 'from anywhere'
                        const fromLabel = document.createElement('label');
                        fromLabel.textContent = 'FROM';
                        fromLabel.style.display = 'block';
                        fromLabel.style.fontWeight = 'bold';
                        fromLabel.appendChild(originSelect);
                        // Trigger change to populate destinations
                        const originSelEl = originSelect.querySelector('select[name="origin"]');
                        if (originSelEl) originSelEl.dispatchEvent(new Event('change'));
                        row.appendChild(fromLabel);
                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        toLabel.appendChild(destinationSelect);
                        row.appendChild(toLabel);
                        // Fill destination options according to current origin
                        const originInputEl = originSelect.querySelector ? originSelect.querySelector('input[name="origin"]') : null;
                        const originSelectEl = originSelect.querySelector ? originSelect.querySelector('select[name="origin"]') : null;
                        if (originInputEl) originInputEl.dispatchEvent(new Event('change'));
                        else if (originSelectEl) originSelectEl.dispatchEvent(new Event('change'));
                        else if (originSelect && originSelect.dispatchEvent) originSelect.dispatchEvent(new Event('change'));
                        // Dates for this row
                        row.appendChild(rowDateSelector.root);
                    }
                }

                fromAnywhereCheckbox.addEventListener('change', renderRowContent);
                renderRowContent();

                return row;
            }

            function renderRowsContainer() {
                dynamicContent.innerHTML = '';
                const rowsContainer = document.createElement('div');
                rowsContainer.id = 'rows-container';
                dynamicContent.appendChild(rowsContainer);

                // Add initial row if none exist
                if (rowsContainer.children.length === 0) {
                    rowsContainer.appendChild(createNoneRow());
                }

                const addRowContainer = document.createElement('div');
                addRowContainer.id = 'add-row-container';
                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.textContent = '+ Add Route';
                addButton.title = 'Add Row';
                addButton.addEventListener('click', () => {
                    // Copy selected dates from the last row
                    const lastRow = rowsContainer.querySelector('.row:last-of-type');
                    let lastSelectedDMY = [];
                    if (lastRow) {
                        lastSelectedDMY = Array.from(lastRow.querySelectorAll('.row-dates-checkboxes input[type="checkbox"]:checked')).map(cb => cb.value);
                    }
                    rowsContainer.appendChild(createNoneRow(lastSelectedDMY));
                });
                addRowContainer.appendChild(addButton);
                dynamicContent.appendChild(addRowContainer);
            }

            // Update the logic for adding rows so the plus button is always below all rows
            // Note: the above listener already handles switching modes; avoid duplicate listeners here.

            // Update the default state for 'none' mode on page load
            const radioNone = document.querySelector('input[type="radio"][name="connection"][value="none"]');
            if (radioNone) {
                radioNone.dispatchEvent(new Event('change'));
            }

            // Helper UI controls
            const submitBtn = document.querySelector('button[type="submit"]');
            const loadingOverlay = document.getElementById('loading-overlay');
            const resultsModal = document.getElementById('results-modal');
            const resultsBody = document.getElementById('results-body');
            const resultsTitle = document.getElementById('results-title');
            const resultsCloseBtn = document.getElementById('results-close-btn');

            function setStartDisabled(disabled) {
                if (!submitBtn) return;
                submitBtn.disabled = disabled;
                submitBtn.style.opacity = disabled ? '0.7' : '1';
                submitBtn.style.cursor = disabled ? 'not-allowed' : 'pointer';
            }
            function showLoading() { if (loadingOverlay) loadingOverlay.style.display = 'flex'; }
            function hideLoading() { if (loadingOverlay) loadingOverlay.style.display = 'none'; }
            function showResults(title, contentNode) {
                if (resultsBody) {
                    resultsBody.innerHTML = '';
                    if (contentNode) resultsBody.appendChild(contentNode);
                }
                if (resultsTitle && title) resultsTitle.textContent = title;
                if (resultsModal) resultsModal.style.display = 'flex';
            }
            function hideResults() {
                if (resultsModal) resultsModal.style.display = 'none';
                if (resultsBody) resultsBody.innerHTML = '';
            }

            // Download helper: fetches /download/<taskId> and triggers a browser download
            async function downloadResults(taskId) {
                if (!taskId) return alert('Missing task id for download');
                try {
                    const a = document.createElement('a');
                    a.href = `https://wizz-flights.onrender.com/download/${encodeURIComponent(taskId)}`
                    a.download = '';
                    a.target = '_blank';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                } catch (err) {
                    console.log('Download error', err);
                    alert('Error downloading the file. Try again later.');
                }
            }

            if (resultsCloseBtn) {
                resultsCloseBtn.addEventListener('click', () => {
                    hideResults();
                    // Remove any download button added dynamically
                    const dl = document.getElementById('results-download-btn');
                    if (dl) dl.remove();
                    setStartDisabled(false); // allow new submission after closing results
                });
            }

            function renderNoResultsMessage() {
                const wrap = document.createElement('div');
                wrap.className = 'card';
                wrap.textContent = 'No results found for this search. Try different dates or routes.';
                return wrap;
            }

            function renderWithMode(dataObj) {
                const container = document.createElement('div');
                const order = ['direct', '1-stop', '2-stops'];
                order.forEach(key => {
                    const arr = Array.isArray(dataObj?.[key]) ? dataObj[key] : [];
                    if (!arr || arr.length === 0) return; // skip empty sections
                    const section = document.createElement('div');
                    section.className = 'results-section';
                    const h = document.createElement('h3');
                    h.textContent = key;
                    const count = document.createElement('span');
                    count.className = 'pill';
                    count.textContent = `${arr.length}`;
                    h.appendChild(count);
                    section.appendChild(h);

                    arr.forEach(route => {
                        const card = document.createElement('div');
                        card.className = 'card';
                        const routeLine = document.createElement('div');
                        routeLine.style.fontWeight = 'bold';
                        routeLine.style.marginBottom = '4px';
                        routeLine.textContent = String(route?.Route || '').trim() || 'Route';
                        const meta = document.createElement('div');
                        meta.style.color = '#374151';
                        meta.style.fontSize = '14px';
                        const price = route?.Total_Price != null ? `Price: ${route.Total_Price}` : '';
                        const ttime = route?.Total_Time != null ? `Time: ${route.Total_Time}` : '';
                        meta.textContent = [price, ttime].filter(Boolean).join(' ‚Ä¢ ');
                        card.appendChild(routeLine);
                        if (meta.textContent) card.appendChild(meta);

                        const segs = Array.isArray(route?.Segments) ? route.Segments : [];
                        if (segs.length) {
                            const segList = document.createElement('div');
                            segList.style.marginTop = '6px';
                            segList.style.fontSize = '13px';
                            // small helper to format a segment date+time if both present, or fallback to time only
                            const formatDateTime = (dateStr, timeStr) => {
                                // dateStr may be like '19 October 2025' or '2025-10-19' or '19/10/2025'
                                const hasDate = dateStr && String(dateStr).trim();
                                const hasTime = timeStr && String(timeStr).trim();
                                if (!hasDate && !hasTime) return '';
                                if (hasDate && hasTime) return `${dateStr} ${timeStr}`;
                                return hasTime ? timeStr : dateStr;
                            };

                            segs.forEach((s, idx) => {
                                const line = document.createElement('div');
                                const from = s.From || s.Origin || s.Departure || '';
                                const to = s.To || s.Destination || s.Arrival || '';
                                const depTime = s.Departure_Time || s.Departure || '';
                                const arrTime = s.Arrival_Time || s.Arrival || '';
                                const depDate = s.Departure_Date || s.Date || '';
                                const arrDate = s.Arrival_Date || s.Date || '';
                                const dep = formatDateTime(depDate, depTime);
                                const arr = formatDateTime(arrDate, arrTime);
                                const code = s.Flight_Code || s.Flight || '';
                                const carrier = s.Carrier || '';
                                const main = [from && to ? `${from} ‚Üí ${to}` : '', dep && arr ? `${dep} ‚Üí ${arr}` : ''].filter(Boolean).join(' | ');
                                const extra = [code, carrier].filter(Boolean).join(' ‚Ä¢ ');
                                line.textContent = `${idx + 1}. ${main}${extra ? ' ‚Äî ' + extra : ''}`;
                                segList.appendChild(line);
                            });
                            card.appendChild(segList);
                        }
                        section.appendChild(card);
                    });
                    container.appendChild(section);
                });
                // If nothing rendered, show no-results
                if (!container.children.length) return renderNoResultsMessage();
                return container;
            }

            function renderNoneMode(arr) {
                const data = Array.isArray(arr) ? arr : [];
                if (data.length === 0) return renderNoResultsMessage();
                const columns = ['From','From_Code','To','To_Code','Date','Status','Flight_Code','Departure_Time','Arrival_Time','Duration','Price','Currency','Stops','Carrier','Departure_Date','Arrival_Date'];
                const wrap = document.createElement('div');
                wrap.className = 'table-wrap';
                const table = document.createElement('table');
                table.className = 'results';
                const thead = document.createElement('thead');
                const trh = document.createElement('tr');
                columns.forEach(c => { const th = document.createElement('th'); th.textContent = c; trh.appendChild(th); });
                thead.appendChild(trh);
                const tbody = document.createElement('tbody');
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    columns.forEach(c => { const td = document.createElement('td'); td.textContent = row?.[c] != null ? String(row[c]) : ''; tr.appendChild(td); });
                    tbody.appendChild(tr);
                });
                table.appendChild(thead);
                table.appendChild(tbody);
                wrap.appendChild(table);
                return wrap;
            }

            document.getElementById('flight-search-form').addEventListener('submit', function (e) {
                e.preventDefault();
                // Collect username and password
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value;
                // Mode
                const mode = document.querySelector('input[type="radio"][name="connection"]:checked').value;
                // Global dates (used only in 'with' mode)
                const globalDateCheckboxes = document.querySelectorAll('#dates-checkboxes input:checked');
                const globalDates = Array.from(globalDateCheckboxes).map(cb => {
                    // Convert DD/MM/YYYY to YYYY-MM-DD
                    const [d, m, y] = cb.value.split('/');
                    return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                });
                // Routes
                let routes = [];
                if (mode === 'with') {
                    // In 'with' mode we may use datalist inputs; extract codes
                    const fromRaw = document.querySelector('input[name="origin"]')?.value || document.querySelector('select[name="origin"]')?.value || '';
                    const toRaw = document.querySelector('input[name="destination"]')?.value || document.querySelector('select[name="destination"]')?.value || '';
                    const from = extractCode(fromRaw);
                    const to = extractCode(toRaw);
                    if (from && to) routes.push([from, to]);
                } else {
                    const rows = document.querySelectorAll('.row');
                    const perRoute = [];
                    let rowIndex = 0;
                    rows.forEach(row => {
                        rowIndex++;
                        // Collect per-row dates (DMY -> ISO)
                        const rowDateCheckboxes = row.querySelectorAll('.row-dates-checkboxes input[type="checkbox"]:checked');
                        const rowDates = Array.from(rowDateCheckboxes).map(cb => {
                            const [d, m, y] = cb.value.split('/');
                            return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                        });
                        if (rowDates.length === 0) {
                            // Flag via data attribute to validate later
                            row.dataset.missingDates = '1';
                        } else {
                            delete row.dataset.missingDates;
                        }
                        const fromAnywhere = row.querySelector('input[name="from-anywhere"]').checked;
                        if (fromAnywhere) {
                            const toRaw = row.querySelector('select[name="anywhere"]')?.value || row.querySelector('input[name="anywhere"]')?.value;
                            const to = extractCode(toRaw);
                            // Find all keys in pairs where to is in the array
                            Object.entries(pairs).forEach(([from, arr]) => {
                                if (to && Array.isArray(arr) && arr.includes(to)) {
                                    perRoute.push({ origin: from, dest: to, dates: rowDates });
                                }
                            });
                        } else {
                            const fromRaw = row.querySelector('input[name="origin"]')?.value || row.querySelector('select[name="origin"]')?.value;
                            const from = extractCode(fromRaw);
                            if (!from) {
                                console.log('Missing origin in one of the rows');
                                return
                            }
                            const toSelect = row.querySelector('select[name="destination"]');
                            if (toSelect.multiple) {
                                Array.from(toSelect.selectedOptions).forEach(opt => {
                                    perRoute.push({ origin: from, dest: opt.value, dates: rowDates });
                                });
                            } else {
                                perRoute.push({ origin: from, dest: toSelect.value, dates: rowDates });
                            }
                        }
                    });
                    routes = perRoute;
                }
                // Validation
                if (!username || !password) {
                    alert('All fields are required. Please fill in all details.');
                    return;
                }
                if (mode === 'with') {
                    console.log(routes, globalDates);
                    if (routes.length === 0 || globalDates.length === 0) {
                        alert('Please choose origin, destination and at least one date.');
                        return;
                    }
                } else {
                    if (routes.length === 0) {
                        alert('Please add at least one route.');
                        return;
                    }
                    // Each row must have at least one date selected
                    const anyMissing = Array.from(document.querySelectorAll('.row')).some(r => r.dataset.missingDates === '1');
                    if (anyMissing) {
                        alert('Each row must have at least one date selected.');
                        return;
                    }
                }
                // Build description field
                let description = '';
                if (mode === 'with') {
                    // flights_with_connections_{from}-{to}_{date1,date2,...}
                    const [from, to] = routes[0] || ['', ''];
                    description = `flights with connections from:${from} to:${to} at: ${globalDates.join(',')}`;
                } else {
                    const uniqueOrigins = Array.from(new Set(routes.map(r => (r.origin || '').trim().toUpperCase())));
                    let fileOrigins = uniqueOrigins.slice(0, 5).join(' ');
                    if (uniqueOrigins.length > 5) fileOrigins += ' etc';
                    if (uniqueOrigins.length == 1 ){
                        const uniqueDests = Array.from(new Set(routes.map(r => (r.dest || '').trim().toUpperCase())));
                        fileOrigins += ' to ' + uniqueDests.slice(0, 5).join(' ') + (uniqueDests.length > 5 ? ' etc' : '');
                    }
                    description = `${fileOrigins}`;
                }
                // Build payload
                let payload;
                if (mode === 'with') {
                    payload = { username, password, routes:[ {'origin':routes[0][0], 'dest':routes[0][1]}], dates: globalDates, mode, description };
                } else {
                    // New per-route format for none mode
                    payload = { username, password, routes, mode, description };
                }
                // Remove any previous message
                let msgDiv = document.getElementById('success-message');
                if (msgDiv) msgDiv.remove();
                // Disable start and show loading immediately
                setStartDisabled(true);
                showLoading();

                const startTask = async (payload) => {
                    try {
                        const resp = await fetch("https://wizz-flights.onrender.com/process", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const data = await resp.json().catch(() => ({}));
                        const taskId = data.task_id;
                        if (!taskId) throw new Error('Missing task id');

                        const evtSource = new EventSource(`https://wizz-flights.onrender.com/stream/${taskId}`);

                        evtSource.onmessage = (e) => {
                            if (e.data === "ping" || !e.data) {
                                // keep waiting
                                return;
                            }
                            
                            // Parse payload
                            let payload = null;
                            try {
                                payload = JSON.parse(e.data);
                            } catch (err) {
                                console.log('Failed parsing SSE data', err, e.data);
                                payload = e.data;
                            }
                            console.log('SSE payload:', payload);

                            // Check for error in payload
                            if (payload && payload.error) {
                                console.log('error', payload.error);
                                hideLoading();
                                setStartDisabled(false);
                                alert('An error occurred: ' + payload.error);
                                evtSource.close();
                                return;
                            }

                            // If payload has 'message', parse it as the inner JSON
                            let innerData = null;
                            if (payload && typeof payload === 'object' && payload.message) {
                                try {
                                    innerData = JSON.parse(payload.message);
                                } catch (err) {
                                    console.log('Failed parsing inner message', err, payload.message);
                                }
                            }
                            console.log(innerData)

                            // Support both legacy (raw results array/object) and new wrapped response
                            let results = null;
                            let returnedTaskId = null;
                            let hasFile = false;
                            let isPartial = false;

                            if (innerData && typeof innerData === 'object' && (innerData.results !== undefined || innerData.task_id !== undefined)) {
                                results = innerData.results;
                                returnedTaskId = innerData.task_id;
                                hasFile = !!innerData.has_file;
                                isPartial = !!innerData.partial;
                            } else if (payload && typeof payload === 'object' && (payload.results !== undefined || payload.task_id !== undefined)) {
                                results = payload.results;
                                returnedTaskId = payload.task_id;
                                hasFile = !!payload.has_file;
                                isPartial = !!payload.partial;
                            } else {
                                // backwards compatibility: payload itself is the results
                                results = payload;
                            }

                            // Handle partial vs final
                            if (!isPartial) {
                                evtSource.close();
                                hideLoading();
                            } else {
                                // Partial: show results but keep connection open
                                hideLoading();
                            }

                            let contentNode;
                            let hasResults = true;
                            if (results == null) {
                                contentNode = renderNoResultsMessage();
                                hasResults = false;
                            } else if (mode === 'with') {
                                contentNode = renderWithMode(results);
                            } else {
                                if (Array.isArray(results) && results.length === 0) {
                                    contentNode = renderNoResultsMessage();
                                    hasResults = false;
                                } else contentNode = renderNoneMode(results);
                            }

                            const title = mode === 'with' ? 'Results: WITH connections' : 'Results: NONE';
                            showResults(title, contentNode);

                            // Add partial warning
                            if (isPartial) {
                                const msgDiv = document.createElement('div');
                                msgDiv.style.backgroundColor = '#fff3cd';
                                msgDiv.style.color = '#856404';
                                msgDiv.style.padding = '10px';
                                msgDiv.style.marginBottom = '10px';
                                msgDiv.style.borderRadius = '4px';
                                msgDiv.style.textAlign = 'center';
                                msgDiv.style.fontWeight = 'bold';
                                msgDiv.textContent = '◊ñ◊î ◊ú◊ê ◊î◊õ◊ú, ◊ê◊†◊ê ◊î◊û◊™◊ü ◊ú◊î◊û◊©◊ö... (Rate Limit)';
                                
                                if (resultsBody) {
                                    resultsBody.insertBefore(msgDiv, resultsBody.firstChild);
                                }
                            }

                            // If the server indicated a downloadable file is available, show a Download button
                            if (hasFile && returnedTaskId && hasResults && !isPartial) {
                                // Create or replace a download button in the modal header
                                let existing = document.getElementById('results-download-btn');
                                if (existing) existing.remove();
                                const btn = document.createElement('button');
                                btn.id = 'results-download-btn';
                                btn.type = 'button';
                                btn.textContent = 'Download Results';
                                btn.title = 'Download results for this task';
                                btn.style.marginLeft = '8px';
                                btn.addEventListener('click', () => downloadResults(returnedTaskId));
                                // place it before the close (X) button so the X stays at the right
                                const header = document.querySelector('#results-modal .modal-header');
                                if (header) {
                                    const closeBtnEl = header.querySelector('#results-close-btn');
                                    if (closeBtnEl) header.insertBefore(btn, closeBtnEl);
                                    else header.appendChild(btn);
                                }
                            }
                            // Keep start button disabled until user closes the results
                        };

                        evtSource.onerror = (e) => {
                            if(e.error){
                                console.log('error', e.error);
                                hideLoading();
                                setStartDisabled(false);
                                alert('An error occurred');
                                evtSource.close();
                            }
                        };
                    } catch (err) {
                        console.log(err);
                        hideLoading();
                        setStartDisabled(false);
                        alert('Error sending the request. Try again later.');
                    }
                }
                startTask(payload)
            });
        }
    </script>
</body>

</html>
