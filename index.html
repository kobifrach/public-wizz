<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='52' font-size='52'%3E%E2%9C%88%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Search</title>
    <style>
        html {
            box-sizing: border-box;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }

        form {
            width: 100%;
            max-width: 420px;
            margin: 12px auto;
            padding: 10px 6px 16px 6px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        label {
            display: block;
            margin-bottom: 2px;
            font-weight: bold;
            font-size: 15px;
        }

        input[type="email"],
        input[type="text"],
        select,
        input[list] {
            width: 100%;
            padding: 10px 8px;
            margin-bottom: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            background: #fafbfc;
        }

        input[list] {
            min-width: 0;
        }

        fieldset {
            border: none;
            margin-bottom: 10px;
            padding: 0;
        }

        legend {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        button {
            display: inline-block;
            padding: 10px 0;
            font-size: 16px;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 8px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button[type="button"] {
            margin-top: 4px;
            width: auto;
            padding: 7px 16px;
            font-size: 15px;
        }

        /* Small subtle button used inside multi-select widgets */
        .multiselect-select-all {
            display: inline-block;
            padding: 4px 8px;
            margin: 6px 0 8px 0;
            font-size: 13px;
            background: transparent;
            color: #007bff;
            border: 1px solid rgba(0,123,255,0.15);
            border-radius: 4px;
            cursor: pointer;
            width: auto;
        }

        .multiselect-select-all:hover {
            background: rgba(0,123,255,0.06);
        }

        /* Small checkbox used inside multi-select widgets */
        .multiselect-select-all-checkbox {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        div {
            margin-bottom: 10px;
        }

        .multi-select-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .row {
            background-color: #f9f9f9;
            padding: 7px 6px 7px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 7px;
            position: relative;
            min-height: 36px;
        }

        .remove-row-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            padding: 8px 10px !important;
            font-size: 18px;
            font-weight: 900;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            line-height: 1;
            z-index: 2;
            height: 34px;
        }

        .remove-row-btn:hover {
            background: #c0392b;
        }

        #add-row-container {
            text-align: center;
            margin-bottom: 10px;
        }

        .divider {
            height: 1px;
            background-color: #ddd;
            margin: 12px 0;
        }

        #dates-checkboxes label {
            display: inline-block;
            margin-right: 8px;
            margin-bottom: 2px;
            font-weight: normal;
            font-size: 14px;
        }

        /* #select-all-dates {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 14px;
            padding: 6px 12px;
        }
 */
        [type="submit"] {
            width: 100%;
            margin: 0;
            font-size: 18px;
            padding: 12px 0;
        }

        h1 {
            font-size: 1.5em;
            margin: 18px 0 10px 0;
            letter-spacing: 1px;
        }

        @media (min-width: 600px) {
            form {
                max-width: 480px;
                padding: 18px 24px 24px 24px;
            }

            h1 {
                font-size: 2.1em;
                margin: 32px 0 12px 0;
            }

            input[type="email"],
            input[type="text"],
            select,
            input[list] {
                font-size: 15px;
                padding: 8px 10px;
            }

            button {
                font-size: 15px;
                padding: 10px 0;
            }

            [type="submit"] {
                font-size: 17px;
                padding: 13px 0;
            }
        }
        /* Compact per-row dates: keep checkboxes and select-all on one line when possible */
        .row-dates-checkboxes {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap; /* allow wrapping on very small screens */
        }
        .row-dates-checkboxes label {
            margin-bottom: 0;
            white-space: nowrap; /* keep each date together */
            font-weight: normal;
            font-size: 13px;
        }
        .row > .multiselect-select-all {
            margin-left: 8px;
            margin-top: 0;
            margin-bottom: 0;
            vertical-align: middle;
        }
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.92);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        #loading-overlay .box {
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 18px 20px;
            max-width: 520px;
            box-shadow: 0 4px 18px rgba(0,0,0,0.08);
            text-align: center;
        }
        .spinner {
            width: 28px;
            height: 28px;
            border: 3px solid #e5e7eb;
            border-top-color: #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Results modal */
        #results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.35);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9998;
            padding: 14px;
        }
        #results-modal .modal {
            background: #fff;
            border-radius: 10px;
            width: min(980px, 96vw);
            max-height: 88vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        #results-modal .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            border-bottom: 1px solid #eee;
            position: relative; /* allow absolutely positioned centered button */
        }
        #results-modal .modal-body {
            padding: 12px 14px;
            overflow: auto;
        }
        #results-close-btn {
            border: none;
            background: #e5e7eb;
            color: #111827;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 13px;
            height: auto;
            width: 44px;
        }
        #results-close-btn:hover { background: #d1d5db; }
        /* Center the download button in the modal header without moving the close X (which stays on the right).
           We use absolute positioning and transform to center horizontally. Keep a sensible z-index. */
        #results-download-btn {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            padding: 6px 12px;
            font-size: 13px;
            background: #007bff;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        #results-download-btn:hover { background: #0056b3; }
        .results-section { margin-bottom: 16px; }
        .pill {
            display: inline-block;
            background: #f3f4f6;
            color: #374151;
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 12px;
            margin-left: 8px;
        }
        .card {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 10px 12px;
            margin: 8px 0;
            background: #fafbfc;
        }
        .table-wrap { overflow: auto; border: 1px solid #eee; border-radius: 6px; }
        table.results { border-collapse: collapse; width: 100%; font-size: 14px; }
        table.results th, table.results td { border: 1px solid #eee; padding: 6px 8px; text-align: left; }
        table.results th { background: #f9fafb; position: sticky; top: 0; z-index: 1; }
        /* Extras modal */
        #extras-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 10001; padding: 14px;
        }
        #extras-modal .modal {
            background: #fff; border-radius: 8px; width: min(500px, 94vw); max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        /* Payment modal */
        #payment-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 10002; padding: 14px;
        }
        #payment-modal .modal {
            background: #fff; border-radius: 8px; width: min(600px, 94vw); max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
    </style>
</head>

<body>
    <h1 style="text-align:center; font-size:2em; margin:32px 0 12px 0; letter-spacing:1px;">
        ‚úàÔ∏è Wizz Flights Search
    </h1>
    <form id="flight-search-form" style="overflow-x: auto;">
        <!-- User Credentials -->
        <label for="username">Username (Email):</label>
        <input type="email" id="username" name="username" autocomplete="username" required>

        <label for="password">Password:</label>
        <input type="text" id="password" name="password" autocomplete="password" required>

        <!-- Connection Mode -->
        <fieldset>
            <legend>Connection Mode:</legend>
            <label>
                <input type="radio" name="connection" value="none" checked> None
            </label>
            <label>
                <input type="radio" name="connection" value="with"> With
            </label>
        </fieldset>

        <!-- Dynamic Content -->
        <div id="dynamic-content"></div>

        <div class="divider"></div>

        <!-- Date Selector -->
    <label for="dates" id="global-dates-label">Select Dates:</label>
    <div id="dates-checkboxes"></div>
    <!-- <button type="button" id="select-all-dates">Select All</button> -->

        <!-- Start Button -->
        <div style="text-align: center; margin: 24px 0;">
            <button type="submit">Start</button>
        </div>
    </form>

    <!-- Loading overlay -->
    <div id="loading-overlay" role="status" aria-live="polite">
        <div class="box">
            <div>
                <span class="spinner" aria-hidden="true"></span>
                <strong>Loading‚Ä¶</strong>
            </div>
            <div style="margin-top:8px; font-size:14px; color:#374151;">
                Request sent. Please do not close the window until completion. If you want to send another request, you can open a new tab.
            </div>
        </div>
    </div>

    <!-- Results modal -->
    <div id="results-modal" aria-modal="true" role="dialog">
        <div class="modal">
            <div class="modal-header">
                <h2 id="results-title" style="margin:0; font-size:18px;">Search Results</h2>
                <button id="results-close-btn" title="Close">X</button>
            </div>
            <div class="modal-body" id="results-body"></div>
        </div>
    </div>

    <!-- Extras modal -->
    <div id="extras-modal">
        <div class="modal">
            <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #eee;">
                <h2 style="margin:0; font-size:16px;">Select Extras</h2>
            </div>
            <div class="modal-body" id="extras-list" style="padding: 10px 12px; overflow: auto;"></div>
            <div style="padding: 10px 12px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px;">
                <button id="extras-cancel-btn" style="background: #e5e7eb; color: #111827; width: auto; padding: 6px 12px;">Cancel</button>
                <button id="extras-confirm-btn" style="background: #e6007e; color: #fff; width: auto; padding: 6px 12px;">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Payment modal -->
    <div id="payment-modal">
        <div class="modal">
            <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #eee;">
                <h2 style="margin:0; font-size:16px;">Booking Summary & Payment</h2>
            </div>
            <div class="modal-body" style="padding: 10px 12px; overflow: auto;">
                <div id="payment-summary" style="margin-bottom: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; border: 1px solid #eee;"></div>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                    <div>
                        <label style="font-size: 11px; margin-bottom: 2px;">Cardholder Name *</label>
                        <input type="text" id="card-name" placeholder="John Doe" required style="margin-bottom: 0;">
                    </div>
                    <div>
                        <label style="font-size: 11px; margin-bottom: 2px;">Card Number *</label>
                        <input type="text" id="card-number" required placeholder="0000 0000 0000 0000" minlength="13" maxlength="19" style="margin-bottom: 0;">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <div style="flex: 1;">
                            <label style="font-size: 11px; margin-bottom: 2px;">Expiry (MM/YY) *</label>
                            <input type="text" id="card-expiry" required placeholder="MM/YY" maxlength="5" minlength="5" style="margin-bottom: 0;">
                        </div>
                        <div style="flex: 1;">
                            <label style="font-size: 11px; margin-bottom: 2px;">CVV *</label>
                            <input type="text" id="card-cvv" required placeholder="123" maxlength="4" minlength="3" style="margin-bottom: 0;">
                        </div>
                    </div>
                </div>
            </div>
            <div style="padding: 10px 12px; border-top: 1px solid #eee; display: flex; justify-content: flex-end; gap: 10px;">
                <button id="payment-cancel-btn" style="background: #e5e7eb; color: #111827; width: auto; padding: 6px 12px;">Cancel</button>
                <button id="payment-confirm-btn" style="background: #e6007e; color: #fff; width: auto; padding: 6px 12px;">Pay Now</button>
            </div>
        </div>
    </div>

    <!-- Screenshot modal -->
    <div id="screenshot-modal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 10003; padding: 14px;">
        <div class="modal" style="background: #fff; border-radius: 8px; width: min(900px, 96vw); max-height: 90vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
            <div class="modal-header" style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #eee;">
                <h2 style="margin:0; font-size:16px;">Booking Screenshot</h2>
                <button id="screenshot-close-btn" style="border:none; background:transparent; font-size:20px; cursor:pointer; color:black;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 10px; overflow: auto; text-align: center;">
                <img id="booking-screenshot-img" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
            </div>
        </div>
    </div>

    <script>
        // pairs: originCode -> [destinationCode]
        // codeToName: airportCode -> display name
        // allDestinationsOptions: [{code, name}] deduplicated
    let pairs = {};
    let codeToName = {};
    let codeToCountry = {};
    let allDestinationsOptions = [];

        // Helper: from a display string like "Bucharest (OTP)" return the code "OTP"
        function extractCode(value) {
            if (!value) return '';
            const match = String(value).match(/\(([^)]+)\)\s*$/);
            if (match) return match[1].trim();
            const upper = String(value).trim().toUpperCase();
            if (codeToName[upper]) return upper; // already a code
            return String(value).trim();
        }

        Promise.all([
            fetch('updated_pairs.json').then(r => r.json()).catch(() => []),
            fetch('airports_origins.json').then(r => r.json()).catch(() => [])
        ])
            .then(([data, airports]) => {
                // Build country mapping
                codeToCountry = {};
                (Array.isArray(airports) ? airports : []).forEach(a => {
                    if (a && a.code) codeToCountry[a.code] = a.country || 'Not Updated Country';
                });

                // data is an array of { code, name, destinations: [{code, name}] }
                const destMap = new Map();
                pairs = {};
                codeToName = {};
                (Array.isArray(data) ? data : []).forEach(origin => {
                    const oCode = origin.code;
                    const oName = origin.name;
                    if (oCode) {
                        codeToName[oCode] = oName || oCode;
                        if (origin.country && !codeToCountry[oCode]) codeToCountry[oCode] = origin.country;
                    }
                    const dests = Array.isArray(origin.destinations) ? origin.destinations : [];
                    pairs[oCode] = dests.map(d => {
                        if (d && d.code) {
                            codeToName[d.code] = d.name || d.code;
                            if (d.country && !codeToCountry[d.code]) codeToCountry[d.code] = d.country;
                            if (!destMap.has(d.code)) destMap.set(d.code, { code: d.code, name: d.name || d.code });
                            return d.code;
                        }
                        return null;
                    }).filter(Boolean);
                });
                allDestinationsOptions = Array.from(destMap.values());
                // Ensure every known origin and destination code has a country entry
                Object.keys(pairs).forEach(oCode => {
                    if (!codeToCountry[oCode]) codeToCountry[oCode] = 'NOT UPDATED COUNTRY';
                    const dests = Array.isArray(pairs[oCode]) ? pairs[oCode] : [];
                    dests.forEach(dCode => {
                        if (!codeToCountry[dCode]) codeToCountry[dCode] = 'NOT UPDATED COUNTRY';
                    });
                });
                // Also ensure any standalone destinations from the master list have a country
                allDestinationsOptions.forEach(({ code }) => {
                    if (!codeToCountry[code]) codeToCountry[code] = 'NOT UPDATED COUNTRY';
                });
                initialize();
            })
            .catch(error => console.error('Error loading data:', error));

        function initialize() {
            const allDestinations = allDestinationsOptions;

            const today = new Date();
            const formatDate = (date) => {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}/${month}/${year}`;
            };

            const dateOptions = [
                { value: 'today', label: formatDate(today) },
                { value: 'tomorrow', label: formatDate(new Date(today.getTime() + 86400000)) },
                { value: 'day-after-tomorrow', label: formatDate(new Date(today.getTime() + 2 * 86400000)) },
                { value: 'two-days-after-tomorrow', label: formatDate(new Date(today.getTime() + 3 * 86400000)) }
            ];

            const dynamicContent = document.getElementById('dynamic-content');
            const connectionRadios = document.getElementsByName('connection');
            const selectAllDatesButton = document.getElementById('select-all-dates');
            const datesCheckboxes = document.getElementById('dates-checkboxes');
            const globalDatesLabel = document.getElementById('global-dates-label');

            function renderDateCheckboxes() {
                datesCheckboxes.innerHTML = '';
                const today = new Date();
                for (let i = 0; i < 4; i++) {
                    const date = new Date(today.getTime() + i * 86400000);
                    const day = String(date.getDate()).padStart(2, '0');
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const year = date.getFullYear();
                    const dateStr = `${day}/${month}/${year}`;
                    const label = document.createElement('label');
                    label.style.fontWeight = 'normal';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = 'dates';
                    checkbox.value = dateStr;
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(' ' + dateStr));
                    datesCheckboxes.appendChild(label);
                    datesCheckboxes.appendChild(document.createElement('br'));
                }
            }

            renderDateCheckboxes();

            connectionRadios.forEach(radio => {
                radio.addEventListener('change', () => {
                    dynamicContent.innerHTML = '';

                    const showGlobalDates = (show) => {
                        if (globalDatesLabel) globalDatesLabel.style.display = show ? 'block' : 'none';
                        if (datesCheckboxes) datesCheckboxes.style.display = show ? 'block' : 'none';
                        if (selectAllDatesButton) selectAllDatesButton.style.display = show ? 'inline-block' : 'none';
                    };

                    // --- WITH mode ---
                    if (radio.value === 'with') {
                        showGlobalDates(true);

                        const fromLabel = document.createElement('label');
                        fromLabel.textContent = 'FROM';
                        fromLabel.style.display = 'block';
                        fromLabel.style.fontWeight = 'bold';
                        const originOptions = Object.keys(pairs).map(code => ({ code, name: codeToName[code] || code }));
                        const originSelect = createComboBox(originOptions, 'origin');
                        fromLabel.appendChild(originSelect);

                        // Trigger change to populate destinations if any
                        const originSelectEl = originSelect.querySelector('select[name="origin"]');
                        if (originSelectEl) originSelectEl.dispatchEvent(new Event('change'));

                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        const destinationSelect = createComboBox(allDestinations, 'destination');
                        toLabel.appendChild(destinationSelect);

                        dynamicContent.appendChild(fromLabel);
                        dynamicContent.appendChild(toLabel);

                        // Change global dates to radios
                        datesCheckboxes.querySelectorAll('input').forEach(input => {
                            input.type = 'radio';
                            input.name = 'global-date';
                        });
                    } else {
                        // NONE mode: hide global dates and render rows with per-row date selectors
                        showGlobalDates(false);
                        renderRowsContainer();

                        // Change global dates to checkboxes
                        datesCheckboxes.querySelectorAll('input').forEach(input => {
                            input.type = 'checkbox';
                            input.removeAttribute('name');
                        });
                    }
                });
            });

            // Repopulate a multi-select with options grouped by country (uses <optgroup>)
            function repopulateMultiSelect(select, list, searchInput) {
                const items = (list || []).map(opt => {
                    const code = typeof opt === 'string' ? opt : opt.code;
                    const name = typeof opt === 'string' ? (codeToName[code] || code) : (opt.name || opt.code);
                    const country = codeToCountry[code] || 'Other';
                    return { code, name, country };
                });
                const grouped = new Map();
                items.forEach(it => {
                    const key = it.country || 'Other';
                    if (!grouped.has(key)) grouped.set(key, []);
                    grouped.get(key).push(it);
                });
                const countries = Array.from(grouped.keys()).sort((a, b) => {
                    const NU = 'NOT UPDATED COUNTRY';
                    const ax = a === NU ? 1 : 0;
                    const bx = b === NU ? 1 : 0;
                    if (ax !== bx) return ax - bx; // NU last
                    return a.localeCompare(b);
                });
                select.innerHTML = '';
                countries.forEach(cty => {
                    const og = document.createElement('optgroup');
                    og.label = cty;
                    grouped.get(cty).sort((a, b) => a.name.localeCompare(b.name)).forEach(({ code, name }) => {
                        const opt = document.createElement('option');
                        opt.value = code;
                        opt.textContent = `${name} (${code})`;
                        opt.dataset.searchKey = `${name} ${code} ${cty}`.toLowerCase();
                        og.appendChild(opt);
                    });
                    select.appendChild(og);
                });
                if (searchInput && searchInput.value && searchInput.value.trim()) {
                    const q = searchInput.value.trim().toLowerCase();
                    for (const opt of select.options) {
                        const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                        opt.hidden = q && !key.includes(q);
                    }
                    // Hide optgroups that have no visible children
                    Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                        const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                        og.hidden = !anyVisible;
                    });
                }
            }

            // Show a small country hint near an origin input/select inside container
            function attachCountryHint(container, fieldName) {
                const el = container.querySelector(`[name="${fieldName}"]`);
                if (!el) return;
                const hint = document.createElement('small');
                hint.style.marginLeft = '6px';
                hint.style.color = '#666';
                hint.style.fontSize = '12px';
                const update = () => {
                    const code = extractCode(el.value || '');
                    const country = codeToCountry[code];
                    hint.textContent = country ? `(${country})` : '';
                };
                el.addEventListener('input', update);
                el.addEventListener('change', update);
                setTimeout(update, 0);
                container.appendChild(hint);
            }

            function createComboBox(options, name, onChangeCallback, isMultiSelect = false) {
                const normalize = (opt) => {
                    if (typeof opt === 'string') {
                        const code = opt;
                        const nm = codeToName[code] || code;
                        return { code, name: nm };
                    }
                    return { code: opt.code, name: opt.name || opt.code };
                };
                const normalized = (options || []).map(normalize);
                if (isMultiSelect) {
                    // MULTI-SELECT with live search filtering
                    const container = document.createElement('div');
                    // Search input
                    const search = document.createElement('input');
                    search.type = 'text';
                    search.placeholder = 'üîé Search destinations‚Ä¶';
                    search.setAttribute('data-search-for', name);
                    search.style.marginBottom = '6px';
                    search.style.width = '100%';
                    search.style.padding = '8px 10px';
                    search.style.border = '1px solid #ccc';
                    search.style.borderRadius = '4px';

                    // Select element
                    const select = document.createElement('select');
                    select.name = name;
                    select.multiple = true;

                    const populateOptions = (list) => {
                        repopulateMultiSelect(select, list, search);
                        // Update the select-all checkbox state after repopulating
                        try { updateSelectAllState(); } catch (e) { /* ignore if not yet defined */ }
                    };

                    const applyFilter = (query) => {
                        const q = query.toLowerCase();
                        for (const opt of select.options) {
                            const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                            opt.hidden = q && !key.includes(q);
                        }
                        // Hide optgroups with no visible children
                        Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                            const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                            og.hidden = !anyVisible;
                        });
                        // Reflect the current visible selection in the checkbox
                        try { updateSelectAllState(); } catch (e) { /* ignore if not yet defined */ }
                    };

                    populateOptions(normalized);

                    if (onChangeCallback) select.addEventListener('change', onChangeCallback);
                    // Keep the select-all checkbox in sync when user selects/deselects options
                    select.addEventListener('change', () => {
                        try { updateSelectAllState(); } catch (e) { /* ignore */ }
                    });
                    search.addEventListener('input', () => applyFilter(search.value.trim()));
                    // Prevent Enter from submitting the form while searching
                    search.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') e.preventDefault();
                    });

                    // Create checkbox + label to toggle select-all for visible options
                    const selectAllWrapper = document.createElement('div');
                    selectAllWrapper.style.display = 'flex';
                    selectAllWrapper.style.alignItems = 'center';
                    selectAllWrapper.style.gap = '8px';
                    selectAllWrapper.style.margin = '6px 0';

                    const selectAllCheckbox = document.createElement('input');
                    selectAllCheckbox.type = 'checkbox';
                    selectAllCheckbox.id = `select-all-${name}`;
                    selectAllCheckbox.className = 'multiselect-select-all-checkbox';

                    const selectAllLabel = document.createElement('label');
                    selectAllLabel.setAttribute('for', selectAllCheckbox.id);
                    selectAllLabel.textContent = 'select all destinations';
                    selectAllLabel.style.fontSize = '13px';
                    selectAllLabel.style.color = '#007bff';

                    // Toggle selects only visible (not hidden) options. If checked -> select visible; if unchecked -> deselect visible.
                    selectAllCheckbox.addEventListener('change', () => {
                        const shouldSelect = selectAllCheckbox.checked;
                        for (const option of select.options) {
                            if (!option.hidden) option.selected = shouldSelect;
                        }
                        // Fire change event so any listeners react to selection changes
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    // Helper: update checkbox state (checked/indeterminate) based on visible options
                    function updateSelectAllState() {
                        const visible = Array.from(select.options).filter(o => !o.hidden);
                        if (visible.length === 0) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                            return;
                        }
                        const selectedCount = visible.filter(o => o.selected).length;
                        if (selectedCount === 0) {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = false;
                        } else if (selectedCount === visible.length) {
                            selectAllCheckbox.checked = true;
                            selectAllCheckbox.indeterminate = false;
                        } else {
                            selectAllCheckbox.checked = false;
                            selectAllCheckbox.indeterminate = true;
                        }
                    }

                    selectAllWrapper.appendChild(selectAllCheckbox);
                    selectAllWrapper.appendChild(selectAllLabel);

                    // Order: search (top), then checkbox+label, then the multi-select list
                    container.appendChild(search);
                    container.appendChild(selectAllWrapper);
                    container.appendChild(select);

                    // Best-effort: clicking an optgroup label selects all its visible options
                    select.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target && target.tagName === 'OPTGROUP') {
                            const opts = Array.from(target.querySelectorAll('option'));
                            const visible = opts.filter(o => !o.hidden);
                            const shouldSelect = visible.some(o => !o.selected);
                            visible.forEach(o => { o.selected = shouldSelect; });
                            select.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                    return container;
                } else {
                    // SINGLE select
                    if (['origin', 'destination'].includes(name)) {
                        // Render as a searchable SELECT grouped by country
                        const container = document.createElement('div');
                        const search = document.createElement('input');
                        search.type = 'text';
                        search.placeholder = name === 'destination' ? 'üîé Search destinations‚Ä¶' : 'üîé Search origins‚Ä¶';
                        search.style.marginBottom = '6px';
                        search.style.width = '100%';
                        search.style.padding = '8px 10px';
                        search.style.border = '1px solid #ccc';
                        search.style.borderRadius = '4px';

                        const select = document.createElement('select');
                        select.name = name;

                        const buildOptions = () => {
                            // Build grouped options by country
                            const byCountry = new Map();
                            normalized.forEach(({ code, name }) => {
                                const country = codeToCountry[code] || 'Other';
                                if (!byCountry.has(country)) byCountry.set(country, []);
                                byCountry.get(country).push({ code, name });
                            });
                            const NU = 'NOT UPDATED COUNTRY';
                            const countries = Array.from(byCountry.keys()).sort((a, b) => {
                                const ax = a === NU ? 1 : 0;
                                const bx = b === NU ? 1 : 0;
                                if (ax !== bx) return ax - bx;
                                return a.localeCompare(b);
                            });
                            select.innerHTML = '';
                            countries.forEach(country => {
                                const og = document.createElement('optgroup');
                                og.label = country;
                                byCountry.get(country).sort((a, b) => a.name.localeCompare(b.name)).forEach(({ code, name }) => {
                                    const opt = document.createElement('option');
                                    opt.value = code;
                                    opt.textContent = `${name} (${code})`;
                                    opt.dataset.searchKey = `${name} ${code} ${country}`.toLowerCase();
                                    og.appendChild(opt);
                                });
                                select.appendChild(og);
                            });
                        };
                        buildOptions();

                        // Set default to TLV for origin
                        if (name === 'origin') select.value = 'TLV';

                        const applyFilter = (query) => {
                            const q = query.toLowerCase();
                            for (const opt of select.options) {
                                const key = opt.dataset.searchKey || `${opt.textContent} ${opt.value}`.toLowerCase();
                                opt.hidden = q && !key.includes(q);
                            }
                            // Hide optgroups with no visible children
                            Array.from(select.querySelectorAll('optgroup')).forEach(og => {
                                const anyVisible = Array.from(og.querySelectorAll('option')).some(o => !o.hidden);
                                og.hidden = !anyVisible;
                            });
                        };

                        search.addEventListener('input', () => applyFilter(search.value.trim()));
                        // Prevent Enter from submitting the form while searching
                        search.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') e.preventDefault();
                        });

                        if (onChangeCallback) select.addEventListener('change', onChangeCallback);

                        container.appendChild(search);
                        container.appendChild(select);
                        return container;
                    } else {
                        // Keep input+datalist UX for other single selects
                        const input = document.createElement('input');
                        input.setAttribute('list', `datalist-${name}`);
                        input.name = name;
                        input.autocomplete = 'off';
                        const datalist = document.createElement('datalist');
                        datalist.id = `datalist-${name}`;
                        normalized.forEach(({ code, name }) => {
                            const opt = document.createElement('option');
                            opt.value = `${name} (${code})`;
                            datalist.appendChild(opt);
                        });
                        if (onChangeCallback) input.addEventListener('change', onChangeCallback);
                        const container = document.createElement('span');
                        container.appendChild(input);
                        container.appendChild(datalist);
                        return container;
                    }
                }
            }

            // Helper to create per-row date selector (4 upcoming days) with "Select All" button
            function createRowDateSelector(preselectedDates = []) {
                const container = document.createElement('div');
                const label = document.createElement('label');
                label.textContent = 'Select Dates:';
                label.style.display = 'block';
                label.style.fontWeight = 'bold';

                const cbWrap = document.createElement('div');
                cbWrap.className = 'row-dates-checkboxes';

                const today = new Date();
                const toDMY = (date) => {
                    const d = String(date.getDate()).padStart(2, '0');
                    const m = String(date.getMonth() + 1).padStart(2, '0');
                    const y = date.getFullYear();
                    return `${d}/${m}/${y}`;
                };

                // build 4 day checkboxes
                const selectedDMY = new Set(preselectedDates);
                for (let i = 0; i < 4; i++) {
                        const date = new Date(today.getTime() + i * 86400000);
                        const dmy = toDMY(date); // DD/MM/YYYY used as value for API
                        const lbl = document.createElement('label');
                        lbl.style.fontWeight = 'normal';
                        lbl.style.display = 'inline-block';
                        lbl.style.marginRight = '6px';
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.name = 'row-date';
                        cb.value = dmy; // keep year in value for API
                        if (selectedDMY.has(dmy)) cb.checked = true;
                        lbl.appendChild(cb);
                        // Display without year to save horizontal space (DD/MM)
                        lbl.appendChild(document.createTextNode(' ' + dmy.slice(0,5)));
                        cbWrap.appendChild(lbl);
                }

                // create a select-all checkbox (can select/deselect and show indeterminate)
                const selectAllWrapper = document.createElement('div');
                selectAllWrapper.style.display = 'inline-flex';
                selectAllWrapper.style.alignItems = 'center';
                selectAllWrapper.style.gap = '6px';
                selectAllWrapper.style.marginLeft = '8px';

                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.className = 'row-select-all-checkbox';
                selectAllCheckbox.title = 'Select/Deselect all visible dates';

                const selectAllLabel = document.createElement('label');
                selectAllLabel.style.fontSize = '13px';
                selectAllLabel.style.color = '#007bff';
                selectAllLabel.textContent = 'select all';

                // Toggle visible checkboxes when user clicks the select-all checkbox
                selectAllCheckbox.addEventListener('change', () => {
                    const shouldCheck = selectAllCheckbox.checked;
                    cbWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = shouldCheck);
                });

                // Keep select-all checkbox state in sync with children
                function updateSelectAllState() {
                    const all = Array.from(cbWrap.querySelectorAll('input[type="checkbox"]'));
                    const visible = all.filter(cb => !cb.hidden);
                    if (visible.length === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                        return;
                    }
                    const checkedCount = visible.filter(cb => cb.checked).length;
                    if (checkedCount === 0) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else if (checkedCount === visible.length) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true;
                    }
                }

                // Attach listeners to children to update state
                cbWrap.addEventListener('change', (e) => {
                    if (e.target && e.target.type === 'checkbox') updateSelectAllState();
                });

                // Initialize state
                setTimeout(updateSelectAllState, 0);

                selectAllWrapper.appendChild(selectAllCheckbox);
                selectAllWrapper.appendChild(selectAllLabel);

                container.appendChild(label);
                container.appendChild(cbWrap);
                container.appendChild(selectAllWrapper);

                return {
                    root: container,
                    getSelectedDMY: () => Array.from(cbWrap.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value),
                    setSelectedDMY: (arr) => {
                        const set = new Set(arr || []);
                        cbWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = set.has(cb.value));
                    }
                };
            }

            function createNoneRow(copyDatesFrom = []) {
                const row = document.createElement('div');
                row.classList.add('row');

                const fromAnywhereCheckbox = document.createElement('input');
                fromAnywhereCheckbox.type = 'checkbox';
                fromAnywhereCheckbox.name = 'from-anywhere';

                const fromAnywhereLabel = document.createElement('label');
                fromAnywhereLabel.textContent = 'From Anywhere';
                fromAnywhereLabel.appendChild(fromAnywhereCheckbox);

                const removeButton = document.createElement('button');
                removeButton.type = 'button';
                removeButton.textContent = '‚Äî';
                removeButton.className = 'remove-row-btn';
                removeButton.title = 'Remove Row';
                removeButton.addEventListener('click', () => {
                    row.remove();
                });

                const originSelect = createComboBox(Object.keys(pairs), 'origin', () => {
                    // Handle both input+datalist and multiselect
                    let selectedOrigin = null;
                    // If originSelect is input+datalist
                    if (originSelect.querySelector('input[name="origin"]')) {
                        selectedOrigin = extractCode(originSelect.querySelector('input[name="origin"]').value);
                    } else if (originSelect.querySelector && originSelect.querySelector('select[name="origin"]')) {
                        selectedOrigin = originSelect.querySelector('select[name="origin"]').value;
                    } else if (originSelect.value !== undefined) {
                        selectedOrigin = originSelect.value; // fallback (in case originSelect IS the select)
                    }
                    const destinationOptions = (pairs[selectedOrigin] || []).map(code => ({ code, name: codeToName[code] || code }));
                    // Find the destination select (could be inside a label)
                    let destinationSelect = row.querySelector('select[name="destination"]');
                    if (!destinationSelect) {
                        // If not found directly, search inside labels
                        const toLabel = Array.from(row.querySelectorAll('label')).find(l => l.textContent.startsWith('TO'));
                        if (toLabel) destinationSelect = toLabel.querySelector('select[name="destination"]');
                    }
                    if (destinationSelect) {
                        const searchInput = row.querySelector('input[data-search-for="destination"]');
                        repopulateMultiSelect(destinationSelect, destinationOptions, searchInput);
                        // Dispatch change so the select-all checkbox for this destinationSelect updates
                        destinationSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });

                const destinationSelect = createComboBox([], 'destination', null, true);

                // Per-row date selector
                const rowDateSelector = createRowDateSelector(copyDatesFrom);

                // When row is rendered, also trigger the originSelect change to fill destination
                function renderRowContent() {
                    row.innerHTML = '';
                    row.appendChild(removeButton);
                    row.appendChild(fromAnywhereLabel);
                    if (fromAnywhereCheckbox.checked) {
                        // Only TO
                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        const anywhereSelect = createComboBox(allDestinations, 'anywhere', null, false);
                        toLabel.appendChild(anywhereSelect);
                        row.appendChild(toLabel);
                        // Dates for this row
                        row.appendChild(rowDateSelector.root);
                    } else {
                        // Always show FROM and TO when not 'from anywhere'
                        const fromLabel = document.createElement('label');
                        fromLabel.textContent = 'FROM';
                        fromLabel.style.display = 'block';
                        fromLabel.style.fontWeight = 'bold';
                        fromLabel.appendChild(originSelect);
                        // Trigger change to populate destinations
                        const originSelEl = originSelect.querySelector('select[name="origin"]');
                        if (originSelEl) originSelEl.dispatchEvent(new Event('change'));
                        row.appendChild(fromLabel);
                        const toLabel = document.createElement('label');
                        toLabel.textContent = 'TO';
                        toLabel.style.display = 'block';
                        toLabel.style.fontWeight = 'bold';
                        toLabel.appendChild(destinationSelect);
                        row.appendChild(toLabel);
                        // Fill destination options according to current origin
                        const originInputEl = originSelect.querySelector ? originSelect.querySelector('input[name="origin"]') : null;
                        const originSelectEl = originSelect.querySelector ? originSelect.querySelector('select[name="origin"]') : null;
                        if (originInputEl) originInputEl.dispatchEvent(new Event('change'));
                        else if (originSelectEl) originSelectEl.dispatchEvent(new Event('change'));
                        else if (originSelect && originSelect.dispatchEvent) originSelect.dispatchEvent(new Event('change'));
                        // Dates for this row
                        row.appendChild(rowDateSelector.root);
                    }
                }

                fromAnywhereCheckbox.addEventListener('change', renderRowContent);
                renderRowContent();

                return row;
            }

            function renderRowsContainer() {
                dynamicContent.innerHTML = '';
                const rowsContainer = document.createElement('div');
                rowsContainer.id = 'rows-container';
                dynamicContent.appendChild(rowsContainer);

                // Add initial row if none exist
                if (rowsContainer.children.length === 0) {
                    rowsContainer.appendChild(createNoneRow());
                }

                const addRowContainer = document.createElement('div');
                addRowContainer.id = 'add-row-container';
                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.textContent = '+ Add Route';
                addButton.title = 'Add Row';
                addButton.addEventListener('click', () => {
                    // Copy selected dates from the last row
                    const lastRow = rowsContainer.querySelector('.row:last-of-type');
                    let lastSelectedDMY = [];
                    if (lastRow) {
                        lastSelectedDMY = Array.from(lastRow.querySelectorAll('.row-dates-checkboxes input[type="checkbox"]:checked')).map(cb => cb.value);
                    }
                    rowsContainer.appendChild(createNoneRow(lastSelectedDMY));
                });
                addRowContainer.appendChild(addButton);
                dynamicContent.appendChild(addRowContainer);
            }

            // Update the logic for adding rows so the plus button is always below all rows
            // Note: the above listener already handles switching modes; avoid duplicate listeners here.

            // Update the default state for 'none' mode on page load
            const radioNone = document.querySelector('input[type="radio"][name="connection"][value="none"]');
            if (radioNone) {
                radioNone.dispatchEvent(new Event('change'));
            }

            // Helper UI controls
            const submitBtn = document.querySelector('button[type="submit"]');
            const loadingOverlay = document.getElementById('loading-overlay');
            const resultsModal = document.getElementById('results-modal');
            const resultsBody = document.getElementById('results-body');
            const resultsTitle = document.getElementById('results-title');
            const resultsCloseBtn = document.getElementById('results-close-btn');

            function setStartDisabled(disabled) {
                if (!submitBtn) return;
                submitBtn.disabled = disabled;
                submitBtn.style.opacity = disabled ? '0.7' : '1';
                submitBtn.style.cursor = disabled ? 'not-allowed' : 'pointer';
            }
            // Disable all BUY buttons (used when a booking is in progress)
            function disableBuyButtons() {
                const btns = document.querySelectorAll('.buy-btn');
                btns.forEach(b => {
                    b.disabled = true;
                    b.style.opacity = '0.6';
                    b.style.cursor = 'not-allowed';
                });
            }

            // Re-enable all BUY buttons
            function enableBuyButtons() {
                const btns = document.querySelectorAll('.buy-btn');
                btns.forEach(b => {
                    b.disabled = false;
                    b.style.opacity = '';
                    b.style.cursor = '';
                });
            }
            // Global flag: true while a booking request is in-flight
            // Prevents starting multiple concurrent BUY requests.
            window.bookingInProgress = false;
            function showLoading() { if (loadingOverlay) loadingOverlay.style.display = 'flex'; }
            function hideLoading() { if (loadingOverlay) loadingOverlay.style.display = 'none'; }
            function showResults(title, contentNode) {
                if (resultsBody) {
                    resultsBody.innerHTML = '';
                    if (contentNode) resultsBody.appendChild(contentNode);
                }
                if (resultsTitle && title) resultsTitle.textContent = title;
                if (resultsModal) resultsModal.style.display = 'flex';
            }
            function hideResults() {
                if (resultsModal) resultsModal.style.display = 'none';
                if (resultsBody) resultsBody.innerHTML = '';
            }

            // Download helper: fetches /download/<taskId> and triggers a browser download
            async function downloadResults(taskId) {
                if (!taskId) return alert('Missing task id for download');
                try {
                    const a = document.createElement('a');
                    a.href = `https://wizz-flights.onrender.com/download/${encodeURIComponent(taskId)}`
                    a.download = '';
                    a.target = '_blank';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                } catch (err) {
                    console.log('Download error', err);
                    alert('Error downloading the file. Try again later.');
                }
            }

            if (resultsCloseBtn) {
                resultsCloseBtn.addEventListener('click', () => {
                    hideResults();
                    // Remove any download button added dynamically
                    const dl = document.getElementById('results-download-btn');
                    if (dl) dl.remove();
                    setStartDisabled(false); // allow new submission after closing results
                });
            }

            function renderNoResultsMessage() {
                const wrap = document.createElement('div');
                wrap.className = 'card';
                wrap.textContent = 'No results found for this search. Try different dates or routes.';
                return wrap;
            }

            function renderWithMode(dataObj) {
                const container = document.createElement('div');
                const order = ['direct', '1-stop', '2-stops'];
                order.forEach(key => {
                    const arr = Array.isArray(dataObj?.[key]) ? dataObj[key] : [];
                    if (!arr || arr.length === 0) return; // skip empty sections
                    const section = document.createElement('div');
                    section.className = 'results-section';
                    const h = document.createElement('h3');
                    h.textContent = key;
                    const count = document.createElement('span');
                    count.className = 'pill';
                    count.textContent = `${arr.length}`;
                    h.appendChild(count);
                    section.appendChild(h);

                    arr.forEach(route => {
                        const card = document.createElement('div');
                        card.className = 'card';
                        const routeLine = document.createElement('div');
                        routeLine.style.fontWeight = 'bold';
                        routeLine.style.marginBottom = '4px';
                        routeLine.textContent = String(route?.Route || '').trim() || 'Route';
                        const meta = document.createElement('div');
                        meta.style.color = '#374151';
                        meta.style.fontSize = '14px';
                        const price = route?.Total_Price != null ? `Price: ${route.Total_Price}` : '';
                        const ttime = route?.Total_Time != null ? `Time: ${route.Total_Time}` : '';
                        meta.textContent = [price, ttime].filter(Boolean).join(' ‚Ä¢ ');
                        card.appendChild(routeLine);
                        if (meta.textContent) card.appendChild(meta);

                        const segs = Array.isArray(route?.Segments) ? route.Segments : [];
                        if (segs.length) {
                            const segList = document.createElement('div');
                            segList.style.marginTop = '6px';
                            segList.style.fontSize = '13px';
                            // small helper to format a segment date+time if both present, or fallback to time only
                            const formatDateTime = (dateStr, timeStr) => {
                                // dateStr may be like '19 October 2025' or '2025-10-19' or '19/10/2025'
                                const hasDate = dateStr && String(dateStr).trim();
                                const hasTime = timeStr && String(timeStr).trim();
                                if (!hasDate && !hasTime) return '';
                                if (hasDate && hasTime) return `${dateStr} ${timeStr}`;
                                return hasTime ? timeStr : dateStr;
                            };

                            segs.forEach((s, idx) => {
                                const line = document.createElement('div');
                                const from = s.From || s.Origin || s.Departure || '';
                                const to = s.To || s.Destination || s.Arrival || '';
                                const depTime = s.Departure_Time || s.Departure || '';
                                const arrTime = s.Arrival_Time || s.Arrival || '';
                                const depDate = s.Departure_Date || s.Date || '';
                                const arrDate = s.Arrival_Date || s.Date || '';
                                const dep = formatDateTime(depDate, depTime);
                                const arr = formatDateTime(arrDate, arrTime);
                                const code = s.Flight_Code || s.Flight || '';
                                const carrier = s.Carrier || '';
                                const main = [from && to ? `${from} ‚Üí ${to}` : '', dep && arr ? `${dep} ‚Üí ${arr}` : ''].filter(Boolean).join(' | ');
                                const extra = [code, carrier].filter(Boolean).join(' ‚Ä¢ ');
                                line.textContent = `${idx + 1}. ${main}${extra ? ' ‚Äî ' + extra : ''}`;
                                segList.appendChild(line);
                            });
                            card.appendChild(segList);
                        }
                        section.appendChild(card);
                    });
                    container.appendChild(section);
                });
                // If nothing rendered, show no-results
                if (!container.children.length) return renderNoResultsMessage();
                return container;
            }

            function renderNoneMode(arr) {
                const data = Array.isArray(arr) ? arr : [];
                if (data.length === 0) return renderNoResultsMessage();
                const columns = ['Action', 'From','From_Code','To','To_Code','Date','Status','Flight_Code','Departure_Time','Arrival_Time','Duration','Price','Currency','Stops','Carrier','Departure_Date','Arrival_Date'];
                const wrap = document.createElement('div');
                wrap.className = 'table-wrap';
                const table = document.createElement('table');
                table.className = 'results';
                const thead = document.createElement('thead');
                const trh = document.createElement('tr');
                columns.forEach(c => { const th = document.createElement('th'); th.textContent = c; trh.appendChild(th); });
                thead.appendChild(trh);
                const tbody = document.createElement('tbody');
                data.forEach(row => {
                    const tr = document.createElement('tr');
                    columns.forEach(c => { 
                        const td = document.createElement('td'); 
                        if (c === 'Action') {
                            const btn = document.createElement('button');
                            btn.className = 'buy-btn';
                            btn.textContent = 'Buy';
                            btn.style.padding = '4px 8px';
                            btn.style.fontSize = '12px';
                            btn.style.backgroundColor = '#28a745';
                            btn.onclick = () => initiateBooking(row);
                            td.appendChild(btn);
                        } else {
                            td.textContent = row?.[c] != null ? String(row[c]) : ''; 
                        }
                        tr.appendChild(td); 
                    });
                    tbody.appendChild(tr);
                });
                table.appendChild(thead);
                table.appendChild(tbody);
                wrap.appendChild(table);
                return wrap;
            }

            document.getElementById('flight-search-form').addEventListener('submit', function (e) {
                e.preventDefault();
                // Collect username and password
                const username = document.getElementById('username').value.trim();
                const password = document.getElementById('password').value;
                // Mode
                const mode = document.querySelector('input[type="radio"][name="connection"]:checked').value;
                // Global dates (used only in 'with' mode)
                const globalDateCheckboxes = document.querySelectorAll('#dates-checkboxes input:checked');
                const globalDates = Array.from(globalDateCheckboxes).map(cb => {
                    // Convert DD/MM/YYYY to YYYY-MM-DD
                    const [d, m, y] = cb.value.split('/');
                    return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                });
                // Routes
                let routes = [];
                if (mode === 'with') {
                    // In 'with' mode we may use datalist inputs; extract codes
                    const fromRaw = document.querySelector('input[name="origin"]')?.value || document.querySelector('select[name="origin"]')?.value || '';
                    const toRaw = document.querySelector('input[name="destination"]')?.value || document.querySelector('select[name="destination"]')?.value || '';
                    const from = extractCode(fromRaw);
                    const to = extractCode(toRaw);
                    if (from && to) routes.push([from, to]);
                } else {
                    const rows = document.querySelectorAll('.row');
                    const perRoute = [];
                    let rowIndex = 0;
                    rows.forEach(row => {
                        rowIndex++;
                        // Collect per-row dates (DMY -> ISO)
                        const rowDateCheckboxes = row.querySelectorAll('.row-dates-checkboxes input[type="checkbox"]:checked');
                        const rowDates = Array.from(rowDateCheckboxes).map(cb => {
                            const [d, m, y] = cb.value.split('/');
                            return `${y}-${m.padStart(2, '0')}-${d.padStart(2, '0')}`;
                        });
                        if (rowDates.length === 0) {
                            // Flag via data attribute to validate later
                            row.dataset.missingDates = '1';
                        } else {
                            delete row.dataset.missingDates;
                        }
                        const fromAnywhere = row.querySelector('input[name="from-anywhere"]').checked;
                        if (fromAnywhere) {
                            const toRaw = row.querySelector('select[name="anywhere"]')?.value || row.querySelector('input[name="anywhere"]')?.value;
                            const to = extractCode(toRaw);
                            // Find all keys in pairs where to is in the array
                            Object.entries(pairs).forEach(([from, arr]) => {
                                if (to && Array.isArray(arr) && arr.includes(to)) {
                                    perRoute.push({ origin: from, dest: to, dates: rowDates });
                                }
                            });
                        } else {
                            const fromRaw = row.querySelector('input[name="origin"]')?.value || row.querySelector('select[name="origin"]')?.value;
                            const from = extractCode(fromRaw);
                            if (!from) {
                                console.log('Missing origin in one of the rows');
                                return
                            }
                            const toSelect = row.querySelector('select[name="destination"]');
                            if (toSelect.multiple) {
                                Array.from(toSelect.selectedOptions).forEach(opt => {
                                    perRoute.push({ origin: from, dest: opt.value, dates: rowDates });
                                });
                            } else {
                                perRoute.push({ origin: from, dest: toSelect.value, dates: rowDates });
                            }
                        }
                    });
                    routes = perRoute;
                }
                // Validation
                if (!username || !password) {
                    alert('All fields are required. Please fill in all details.');
                    return;
                }
                if (mode === 'with') {
                    console.log(routes, globalDates);
                    if (routes.length === 0 || globalDates.length === 0) {
                        alert('Please choose origin, destination and at least one date.');
                        return;
                    }
                } else {
                    if (routes.length === 0) {
                        alert('Please add at least one route.');
                        return;
                    }
                    // Each row must have at least one date selected
                    const anyMissing = Array.from(document.querySelectorAll('.row')).some(r => r.dataset.missingDates === '1');
                    if (anyMissing) {
                        alert('Each row must have at least one date selected.');
                        return;
                    }
                }
                // Build description field
                let description = '';
                if (mode === 'with') {
                    // flights_with_connections_{from}-{to}_{date1,date2,...}
                    const [from, to] = routes[0] || ['', ''];
                    description = `flights with connections from:${from} to:${to} at: ${globalDates.join(',')}`;
                } else {
                    const uniqueOrigins = Array.from(new Set(routes.map(r => (r.origin || '').trim().toUpperCase())));
                    let fileOrigins = uniqueOrigins.slice(0, 5).join(' ');
                    if (uniqueOrigins.length > 5) fileOrigins += ' etc';
                    if (uniqueOrigins.length == 1 ){
                        const uniqueDests = Array.from(new Set(routes.map(r => (r.dest || '').trim().toUpperCase())));
                        fileOrigins += ' to ' + uniqueDests.slice(0, 5).join(' ') + (uniqueDests.length > 5 ? ' etc' : '');
                    }
                    description = `${fileOrigins}`;
                }
                // Build payload
                let payload;
                if (mode === 'with') {
                    payload = { username, password, routes:[ {'origin':routes[0][0], 'dest':routes[0][1]}], dates: globalDates, mode, description };
                } else {
                    // New per-route format for none mode
                    payload = { username, password, routes, mode, description };
                }
                // Remove any previous message
                let msgDiv = document.getElementById('success-message');
                if (msgDiv) msgDiv.remove();
                // Disable start and show loading immediately
                setStartDisabled(true);
                showLoading();

                const startTask = async (payload) => {
                    const API_BASE = "https://wizz-flights.onrender.com";

                    const renderPayload = (payloadObj, meta = {}) => {
                        const { done = false } = meta;

                        // If nothing received yet and still running, show in-progress message
                        if (!payloadObj) {
                            const wrap = document.createElement('div');
                            wrap.className = 'card';
                            wrap.style.textAlign = 'center';
                            wrap.textContent = 'Scanning... results will appear here soon.';
                            showResults('Results', wrap);
                            hideLoading();
                            return { stop: false };
                        }

                        if (payloadObj && payloadObj.error) {
                            hideLoading();
                            setStartDisabled(false);
                            const wrap = document.createElement('div');
                            wrap.className = 'card';
                            wrap.textContent = `No results found or an error occurred`;
                            showResults('Results', wrap);
                            return { stop: true };
                        }

                        // If payload has nested message, prefer it
                        let dataNode = payloadObj;
                        if (payloadObj && typeof payloadObj === 'object' && payloadObj.message) {
                            try {
                                dataNode = typeof payloadObj.message === 'string' ? JSON.parse(payloadObj.message) : payloadObj.message;
                            } catch (err) {
                                console.log('Failed parsing inner message', err, payloadObj.message);
                            }
                        }

                            let results = null;
                            let returnedTaskId = null;
                            let hasFile = !!meta.hasFile;
                            let isPartial = meta.isPartial === true;

                        if (dataNode && typeof dataNode === 'object' && (dataNode.results !== undefined || dataNode.task_id !== undefined)) {
                            results = dataNode.results;
                            returnedTaskId = dataNode.task_id;
                            hasFile = meta.hasFile !== undefined ? meta.hasFile : !!dataNode.has_file;
                            isPartial = meta.isPartial !== undefined ? meta.isPartial : !!dataNode.partial;
                        } else {
                            results = dataNode;
                            returnedTaskId = meta.taskIdOverride || null;
                        }

                        hideLoading();

                        let contentNode;
                        let hasResults = true;
                        if (results == null) {
                            if (done) {
                                contentNode = renderNoResultsMessage();
                                hasResults = false;
                            } else {
                                const wrap = document.createElement('div');
                                wrap.className = 'card';
                                wrap.style.textAlign = 'center';
                                wrap.textContent = 'Scanning... results will appear here soon.';
                                contentNode = wrap;
                                hasResults = false;
                            }
                        } else if (mode === 'with') {
                            contentNode = renderWithMode(results);
                        } else {
                            if (Array.isArray(results) && results.length === 0) {
                                if (done) {
                                    contentNode = renderNoResultsMessage();
                                    hasResults = false;
                                } else {
                                    const wrap = document.createElement('div');
                                    wrap.className = 'card';
                                    wrap.style.textAlign = 'center';
                                    wrap.textContent = 'Scanning... results will appear here soon.';
                                    contentNode = wrap;
                                    hasResults = false;
                                }
                            } else contentNode = renderNoneMode(results);
                        }

                        // Mark partial results explicitly
                        if (isPartial) {
                            const badge = document.createElement('div');
                            badge.style.backgroundColor = '#e1ecff';
                            badge.style.color = '#1d4ed8';
                            badge.style.padding = '8px';
                            badge.style.marginBottom = '10px';
                            badge.style.borderRadius = '4px';
                            badge.style.textAlign = 'center';
                            badge.style.fontWeight = 'bold';
                            badge.textContent = 'Partial results (still running)...';
                            if (contentNode && contentNode.prepend) contentNode.prepend(badge);
                        }

                        const title = mode === 'with' ? 'Results: WITH connections' : 'Results: NONE';
                        showResults(title, contentNode);

                        if (hasFile && returnedTaskId && hasResults && !isPartial) {
                            let existing = document.getElementById('results-download-btn');
                            if (existing) existing.remove();
                            const btn = document.createElement('button');
                            btn.id = 'results-download-btn';
                            btn.type = 'button';
                            btn.textContent = 'Download Results';
                            btn.title = 'Download results for this task';
                            btn.style.marginLeft = '8px';
                            btn.addEventListener('click', () => downloadResults(returnedTaskId));
                            const header = document.querySelector('#results-modal .modal-header');
                            if (header) {
                                const closeBtnEl = header.querySelector('#results-close-btn');
                                if (closeBtnEl) header.insertBefore(btn, closeBtnEl);
                                else header.appendChild(btn);
                            }
                        }

                        return { stop: false, isPartial };
                    };

                    try {
                        const resp = await fetch(`${API_BASE}/process`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                        const data = await resp.json().catch(() => ({}));
                        const taskId = data.task_id;
                        if (!taskId) throw new Error('Missing task id');

                        const pollIntervalMs = 20000;
                        let lastSignature = null;
                        let pollHandle = null;

                        const pollOnce = async () => {
                            try {
                                const statusResp = await fetch(`${API_BASE}/status/${taskId}`);
                                if (!statusResp.ok) throw new Error(`Status HTTP ${statusResp.status}`);
                                const statusData = await statusResp.json();
                                if (statusData.error) {
                                    hideLoading();
                                    setStartDisabled(false);
                                    alert('An error occurred: ' + statusData.error);
                                    if (pollHandle) clearInterval(pollHandle);
                                    return;
                                }

                                const payloadData = statusData.data || statusData;
                                const isPartial = statusData.partial || (payloadData && payloadData.partial);
                                const done = statusData.done || statusData.status === 'done';
                                const hasFile = statusData.has_file || (payloadData && payloadData.has_file);

                                const signature = JSON.stringify(payloadData || {});
                                if (!done && signature === lastSignature) return;
                                lastSignature = signature;

                                const result = renderPayload(payloadData, { isPartial, hasFile, taskIdOverride: taskId, done });
                                if (result.stop) {
                                    if (pollHandle) clearInterval(pollHandle);
                                    return;
                                }

                                if (done && !isPartial) {
                                    if (pollHandle) clearInterval(pollHandle);
                                }
                            } catch (err) {
                                console.log('Polling error', err);
                                hideLoading();
                                setStartDisabled(false);
                                if (pollHandle) clearInterval(pollHandle);
                                alert('Error while polling results.');
                            }
                        };

                        // Kick off immediately, then continue polling
                        await pollOnce();
                        pollHandle = setInterval(pollOnce, pollIntervalMs);

                    } catch (err) {
                        console.log(err);
                        hideLoading();
                        setStartDisabled(false);
                        alert('Error sending the request. Try again later.');
                    }
                }
                startTask(payload)
            });
        }
        // --- Booking Logic ---

        // Show credentials refresh dialog
        function showCredentialsRefreshDialog() {
            return new Promise((resolve) => {
                // Create modal overlay
                window.__authDialogOpen = true;
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    inset: 0;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: #fff;
                    padding: 16px;
                    border-radius: 8px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                    width: 90%;
                    max-width: 400px;
                `;
                
                modal.innerHTML = `
                    <h3 style="margin-top:0; margin-bottom:12px; font-size:16px;">Authentication</h3>
                    <p style="margin-top:0; margin-bottom:10px; font-size:13px;">Please log in again to continue.</p>
                    <label for="refresh-username" style="display:block; margin-bottom:4px; font-weight:bold;">Username (Email):</label>
                    <input type="email" id="refresh-username" style="width:100%; padding:6px; margin-bottom:8px; border:1px solid #ccc; border-radius:4px;">
                    <label for="refresh-password" style="display:block; margin-bottom:4px; font-weight:bold;">Password:</label>
                    <input type="text" id="refresh-password" style="width:100%; padding:6px; margin-bottom:12px; border:1px solid #ccc; border-radius:4px;">
                    <label style="display:flex; align-items:center; margin-bottom:16px; font-size: 12px; user-select: none;">
                        <input type="checkbox" id="refresh-remember" checked style="width:auto; margin-right:6px;"> Remember me
                    </label>
                    <div style="text-align: right;">
                        <button id="refresh-ok" style="padding: 6px 12px; font-size: 14px; background-color: #007bff; border:none; border-radius:4px; color:white; cursor:pointer;">Login</button>
                    </div>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Focus on username field
                setTimeout(() => document.getElementById('refresh-username').focus(), 100);
                
                const closeAndResolve = (value) => {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                    }
                    window.__authDialogOpen = false;
                    resolve(value);
                };

                // Handle OK button
                document.getElementById('refresh-ok').onclick = () => {
                    const username = document.getElementById('refresh-username').value;
                    const password = document.getElementById('refresh-password').value;
                    const remember = document.getElementById('refresh-remember').checked;
                    if (!username || !password) {
                        alert('Please enter both username and password.');
                        return;
                    }
                    closeAndResolve({ username, password, remember });
                };
                
                // Prevent closing the dialog by clicking outside the modal
                overlay.addEventListener('click', () => {
                    // Do nothing, to prevent closing on overlay click
                });

                // Also ensure clicks inside the modal don't propagate to overlay
                modal.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
                
                // Handle Enter key for login
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('refresh-ok').click();
                    }
                });
            });
        }

        window.showExtrasDialog = function(offeredExtras) {
            return new Promise((resolve) => {
                const modal = document.getElementById('extras-modal');
                const list = document.getElementById('extras-list');
                list.innerHTML = '';
                
                if (!offeredExtras || offeredExtras.length === 0) {
                    list.innerHTML = '<p style="text-align:center; padding:20px;">No extras available for this flight.</p>';
                } else {
                    offeredExtras.forEach((extra, index) => {
                        const div = document.createElement('div');
                        div.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #eee;';
                        
                        const label = document.createElement('label');
                        label.style.cssText = 'display: flex; align-items: center; gap: 10px; cursor: pointer; margin-bottom: 0; font-weight: normal; flex: 1;';
                        
                        const cb = document.createElement('input');
                        cb.type = 'checkbox';
                        cb.value = index;
                        cb.style.width = 'auto';
                        
                        const text = document.createElement('span');
                        text.innerHTML = `<strong style="font-size:13px;">${extra.title}</strong><br><span style="color:#666; font-size:11px;">${extra.price.replace('\n', ' ')}</span>`;
                        
                        label.appendChild(cb);
                        label.appendChild(text);
                        div.appendChild(label);
                        list.appendChild(div);
                    });
                }
                
                modal.style.display = 'flex';
                
                document.getElementById('extras-confirm-btn').onclick = () => {
                    const selected = [];
                    list.querySelectorAll('input:checked').forEach(cb => {
                        selected.push(offeredExtras[cb.value]);
                    });
                    modal.style.display = 'none';
                    resolve(selected);
                };
                
                document.getElementById('extras-cancel-btn').onclick = () => {
                    modal.style.display = 'none';
                    resolve([]);
                };
            });
        };

        window.showPaymentDialog = function(summary) {
            return new Promise((resolve) => {
                const modal = document.getElementById('payment-modal');
                const summaryDiv = document.getElementById('payment-summary');
                
                let itemsHtml = (summary.items || []).map(item => `
                    <div style="display:flex; justify-content:space-between; font-size:11px; margin-bottom:4px;">
                        <span style="color:#555;">${item.description}</span>
                        <span style="font-weight:bold;">${item.price}</span>
                    </div>
                `).join('');
                
                summaryDiv.innerHTML = `
                    <div style="font-weight:bold; margin-bottom:8px; border-bottom:1px solid #ddd; padding-bottom:4px; font-size:13px; color:#e6007e;">
                        ${summary.route} | ${summary.date}
                    </div>
                    ${itemsHtml}
                    <div style="margin-top:8px; padding-top:8px; border-top:2px solid #e6007e; font-weight:bold; display:flex; justify-content:space-between; font-size:14px;">
                        <span>Total Price</span>
                        <span>${summary.total}</span>
                    </div>
                `;
                
                modal.style.display = 'flex';
                
                document.getElementById('payment-confirm-btn').onclick = () => {
                    const result = {
                        name: document.getElementById('card-name').value.trim(),
                        number: document.getElementById('card-number').value.replace(/\s/g, ''),
                        expiry: document.getElementById('card-expiry').value.trim(),
                        cvv: document.getElementById('card-cvv').value.trim()
                    };
                    
                    if (!result.name || !result.number || !result.expiry || !result.cvv) {
                        alert('Please fill in all payment details.');
                        return;
                    }

                    // Basic validation for expiry format MM/YY
                    if (!/^\d{2}\/\d{2}$/.test(result.expiry)) {
                        alert('Expiry date must be in MM/YY format.');
                        return;
                    }
                    
                    modal.style.display = 'none';
                    resolve(result);
                };
                
                document.getElementById('payment-cancel-btn').onclick = () => {
                    modal.style.display = 'none';
                    resolve(null);
                };
            });
        };

        function showScreenshot(base64Data) {
            const modal = document.getElementById('screenshot-modal');
            const img = document.getElementById('booking-screenshot-img');
            img.src = 'data:image/png;base64,' + base64Data;
            modal.style.display = 'flex';
        }

        document.getElementById('screenshot-close-btn').onclick = () => {
            document.getElementById('screenshot-modal').style.display = 'none';
        };

        async function initiateBooking(row) {
            // Prevent starting another booking while one is in progress
            if (window.bookingInProgress) {
                alert('◊ê◊†◊ê ◊î◊û◊™◊ü ◊ú◊°◊ô◊ï◊ù ◊î◊ë◊ß◊©◊î');
                return;
            }

            if (!confirm(`Start booking for ${row.From_Code} -> ${row.To_Code} on ${row.Date}?`)) return;
            // Mark booking as in-progress and disable buy buttons
            window.bookingInProgress = true;
            try { disableBuyButtons(); } catch (e) { /* ignore */ }
                        
            try {
                // Start booking
                const resp = await fetch("https://wizz-flights.onrender.com/buy_flight", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        origin: row.From_Code,
                        destination: row.To_Code,
                        date: row.Date, // Assuming YYYY-MM-DD or compatible
                        flight_code: row.Flight_Code
                    })
                });
                
                if (!resp.ok) throw new Error("Failed to start booking");
                const { task_id } = await resp.json();
                
                initiateBookingLoop(task_id);

            } catch (e) {
                // clear in-progress flag so user can retry
                window.bookingInProgress = false;
                try { enableBuyButtons(); } catch (err) { /* ignore */ }
                alert("Error: " + e.message);
            }
        }

        async function initiateBookingLoop(task_id) {
             const pollInterval = setInterval(async () => {
                    try {
                        const statusResp = await fetch(`https://wizz-flights.onrender.com/check_booking_status/${task_id}`);
                        if (!statusResp.ok) return;
                        const statusData = await statusResp.json();
                        
                        if (statusData.status === 'waiting_for_extras') {
                            clearInterval(pollInterval);
                            const selected = await window.showExtrasDialog(statusData.data);
                            await fetch(`https://wizz-flights.onrender.com/submit_booking_response/${task_id}`, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(selected)
                            });
                            initiateBookingLoop(task_id);
                            
                        } else if (statusData.status === 'waiting_for_payment') {
                            clearInterval(pollInterval);
                            const paymentDetails = await window.showPaymentDialog(statusData.data);
                            await fetch(`https://wizz-flights.onrender.com/submit_booking_response/${task_id}`, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify(paymentDetails) // null if cancelled
                            });
                            initiateBookingLoop(task_id);
                            
                        } else if (statusData.status === 'waiting_for_credentials') {
                             clearInterval(pollInterval);
                             // Ensure showCredentialsRefreshDialog exists
                             if (window.showCredentialsRefreshDialog) {
                                 const creds = await window.showCredentialsRefreshDialog();
                                 await fetch(`https://wizz-flights.onrender.com/submit_booking_response/${task_id}`, {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify(creds)
                                });
                             } else {
                                 // Fallback
                                 const u = prompt("Enter Username:");
                                 const p = prompt("Enter Password:");
                                 await fetch(`https://wizz-flights.onrender.com/submit_booking_response/${task_id}`, {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify({username: u, password: p})
                                });
                             }
                            initiateBookingLoop(task_id);

                        } else if (statusData.status === 'completed') {
                            clearInterval(pollInterval);
                            // booking finished
                            window.bookingInProgress = false;
                            try { enableBuyButtons(); } catch (e) { /* ignore */ }
                            
                            if (statusData.screenshot) {
                                showScreenshot(statusData.screenshot);
                            }
                            alert("Booking completed successfully!");
                        } else if (statusData.status === 'error') {
                            clearInterval(pollInterval);
                            // booking failed
                            window.bookingInProgress = false;
                            try { enableBuyButtons(); } catch (e) { /* ignore */ }
                            
                            if (statusData.screenshot) {
                                showScreenshot(statusData.screenshot);
                            }
                            alert("Booking failed: " + statusData.error);
                        }
                    } catch (e) {
                        console.error("Polling error", e);
                        // on unexpected polling error, clear flag so user can retry
                        try { clearInterval(pollInterval); } catch (err) { /* ignore */ }
                        window.bookingInProgress = false;
                        try { enableBuyButtons(); } catch (err) { /* ignore */ }
                    }
                }, 20000);
        }
    </script>
</body>

</html>